#! /usr/bin/env python3
# coding=utf-8

# /path/to/openjdk/jdk/src/java.base/share/classes/java/io/DataInputStream.java
from __future__ import print_function

import sys
import inspect
import argparse
import os
import re
import struct
import zipfile
from collections import namedtuple

PY2 = sys.version_info[0] == 2
PY3 = sys.version_info[0] == 3

if PY2:
    import cStringIO

if PY3:
    import io


def identity_function(x):
    return x


if PY3:
    def str2bytes(s):
        return s.encode('utf-8')


    def int2byte(i):
        return bytes((i,))


    def bytes2str(b):
        return b.decode('utf-8')
else:
    str2bytes = identity_function
    int2byte = chr
    bytes2str = identity_function


def tostring(b):
    """ Convert the given bytes or string object to string
    """
    if isinstance(b, bytes):
        return bytes2str(b)
    else:
        return b


MatchResult = namedtuple('MatchResult', ' '.join([
    'matching_line',
    'matching_line_number',
    'matching_column_ranges']))


# Matcher
class ContentMatcher(object):
    def __init__(self,
                 pattern,
                 ignore_case=False,
                 whole_words=False,
                 literal_pattern=False,
                 invert_match=False):
        self.regex = ContentMatcher._create_regex(pattern,
                                                  ignore_case=ignore_case,
                                                  whole_words=whole_words,
                                                  literal_pattern=literal_pattern)
        if invert_match:
            self.match_line = self.inverted_matcher
        else:
            self.match_line = self.matcher

        # Cache frequently used attributes for faster access
        self._finditer = self.regex.finditer
        self._search = self.regex.search

        # Optimize a common case: searching for a simple non-regex string.
        # In this case, we don't need regex matching - using str.find is
        # faster.
        self._find_str = None
        if not ignore_case and not whole_words and ContentMatcher._pattern_is_simple(pattern):
            self._find_str = pattern
            self._find_str_len = len(self._find_str)

    def matcher(self, line):
        try:
            if self._find_str:
                # Make the common case faster: there's no match in this line, so
                # bail out ASAP.
                index = line.find(self._find_str, 0)
                if index == -1:
                    return
                col_ranges = []
                while index >= 0:
                    next_start = index + self._find_str_len
                    col_ranges.append((index, next_start))
                    index = line.find(self._find_str, next_start)
            else:
                col_ranges = [match.span() for match in self._finditer(line) if match]

            if col_ranges:
                yield MatchResult(line, line_number, col_ranges)
        except Exception as err:
            print(err)

    def inverted_matcher(self, line):
        try:
            search_result = self._search(line)

            if search_result is None:
                yield MatchResult(line, line_number, [])
        except Exception as err:
            print(err)

    @staticmethod
    def _pattern_is_simple(pattern):
        """ A "simple" pattern that can be matched with str.find and doesn't
            require a regex engine.
        """
        return bool(re.match('[\w_]+$', tostring(pattern)))

    @staticmethod
    def _create_regex(pattern,
                      ignore_case=False,
                      whole_words=False,
                      literal_pattern=False):
        """ Utility for creating the compiled regex from pattern and options.
        """
        if literal_pattern:
            pattern = re.escape(pattern)
        if whole_words:
            b = r'\b' if isinstance(pattern, str) else br'\b'
            pattern = b + pattern + b

        regex = re.compile(pattern, re.I if ignore_case else 0)
        return regex


# Memoization
class Memoize:
    """Memoize(fn) - an instance which acts like fn but memoizes its arguments
       Will only work on functions with non-mutable arguments
    """

    def __init__(self, fn):
        self.fn = fn
        self.memo = {}

    def __call__(self, *args):
        if not self.memo.has_key(args):
            self.memo[args] = self.fn(*args)
        return self.memo[args]


class MemoizeMutable:
    """Memoize(fn) - an instance which acts like fn but memoizes its arguments
       Will work on functions with mutable arguments (slower than Memoize)
    """

    def __init__(self, fn):
        self.fn = fn
        self.memo = {}

    def __call__(self, *args):
        try:
            import cPickle
            args_str = cPickle.dumps(args)
            if not self.memo.has_key(args_str):
                self.memo[args_str] = self.fn(*args)
            return self.memo[args_str]
        except ModuleNotFoundError:
            pass


# --- basic type
# here we assume the endian-ess of class file is big-endian

class u:
    def __init__(self):
        self.value = None


class u1(u):
    def __init__(self):
        u.__init__(self)

    def u1_2int(self):
        return struct.unpack(">B", self.value)[0]

    def read(self, f):
        self.value = f.read(1)


class u2(u):
    def __init__(self):
        u.__init__(self)

    def u2_2int(self):
        return struct.unpack(">H", self.value)[0]

    def read(self, f):
        self.value = f.read(2)


class u4(u):
    def __init__(self):
        u.__init__(self)

    def u4_2int(self):
        return struct.unpack(">I", self.value)[0]

    def u4_2float(self):
        return struct.unpack(">f", self.value)[0]

    def read(self, f):
        self.value = f.read(4)


class un(u):
    def __init__(self):
        u.__init__(self)
        # self.value = []

    def read(self, f, n):
        # for _ in range(n):
        #    temp = u1()
        #    temp.read(f)
        #    self.value.append(temp)
        self.value = f.read(n)

    def un_2str(self):
        # result = ''
        # for v in self.value:
        #    result = result + v.value.decode()
        # return result
        return self.utf8m_to_utf8s(self.value)

    def utf8m_to_utf8s(self, string):
        """
        :param string: modified utf8 encoded string
        :return: utf8 encoded string
        """
        new_string = []
        length = len(string)
        i = 0
        while i < length:
            byte1 = string[i]
            if (byte1 & 0x80) == 0:  # 1byte encoding
                new_string.append(byte1)
            elif (byte1 & 0xE0) == 0xC0:  # 2byte encoding
                i += 1
                byte2 = string[i]
                if byte1 != 0xC0 or byte2 != 0x80:
                    new_string.append(byte1)
                    new_string.append(byte2)
                else:
                    new_string.append(0)
            elif (byte1 & 0xF0) == 0xE0:  # 3byte encoding
                i += 1
                byte2 = string[i]
                i += 1
                byte3 = string[i]
                if i + 3 < length and byte1 == 0xED and (byte2 & 0xF0) == 0xA0:
                    # See if this is a pair of 3byte encodings
                    byte4 = string[i + 1]
                    byte5 = string[i + 2]
                    byte6 = string[i + 3]
                    if byte4 == 0xED and (byte5 & 0xF0) == 0xB0:
                        # Bits in: 11101101 1010xxxx 10xxxxxx
                        # Bits in: 11101101 1011xxxx 10xxxxxx
                        i += 3

                        # Reconstruct 21 bit code
                        u21 = ((byte2 & 0x0F) + 1) << 16
                        u21 += (byte3 & 0x3F) << 10
                        u21 += (byte5 & 0x0F) << 6
                        u21 += (byte6 & 0x3F)

                        # Bits out: 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx

                        # Convert to 4byte encoding
                        new_string.append(0xF0 + ((u21 >> 18) & 0x07))
                        new_string.append(0x80 + ((u21 >> 12) & 0x3F))
                        new_string.append(0x80 + ((u21 >> 6) & 0x3F))
                        new_string.append(0x80 + (u21 & 0x3F))
                        continue
                new_string.append(byte1)
                new_string.append(byte2)
                new_string.append(byte3)
            i += 1
        return bytes(new_string).decode('utf-8')


# ------------------------------------------ constant pool ------------------------------------------

class constant_pool_info:
    def __init__(self):
        self.tag = u1()

    def read(self, f):
        self.tag.read(f)

    def search(self, matcher):
        if matcher is None:
            # for pattern be empty, just return true
            return True
        matches = list(matcher.match_line(self.dump()))
        if matches:
            return True
        return False

    def dump(self):
        pass

    def is_class(self):
        if self.tag.u1_2int() == 7:
            return True
        else:
            return False

    def is_field_ref(self):
        if self.tag.u1_2int() == 9:
            return True
        else:
            return False

    def is_method_ref(self):
        if self.tag.u1_2int() == 10:
            return True
        else:
            return False

    def is_interface_method_ref(self):
        if self.tag.u1_2int() == 11:
            return True
        else:
            return False

    def is_string(self):
        if self.tag.u1_2int() == 8:
            return True
        else:
            return False

    def is_integer(self):
        if self.tag.u1_2int() == 3:
            return True
        else:
            return False

    def is_float(self):
        if self.tag.u1_2int() == 4:
            return True
        else:
            return False

    def is_long(self):
        if self.tag.u1_2int() == 5:
            return True
        else:
            return False

    def is_double(self):
        if self.tag.u1_2int() == 6:
            return True
        else:
            return False

    def is_name_and_type(self):
        if self.tag.u1_2int() == 12:
            return True
        else:
            return False

    def is_utf8(self):
        if self.tag.u1_2int() == 1:
            return True
        else:
            return False

    def is_method_handle(self):
        if self.tag.u1_2int() == 15:
            return True
        else:
            return False

    def is_method_type(self):
        if self.tag.u1_2int() == 16:
            return True
        else:
            return False

    def is_invoke_dynamic(self):
        if self.tag.u1_2int() == 18:
            return True
        else:
            return False


class class_info(constant_pool_info):
    def __init__(self, ci=constant_pool_info()):
        constant_pool_info.__init__(self)
        self.tag = ci.tag
        self.name_index = u2()

    def read_info(self, f):
        self.name_index.read(f)

    def dump(self):
        return '{\'type\':\'class_info\',\'name_index\':' + str(self.name_index.u2_2int()) + '}'


class field_ref_info(constant_pool_info):
    def __init__(self, ci=constant_pool_info()):
        constant_pool_info.__init__(self)
        self.tag = ci.tag
        self.class_index = u2()
        self.name_and_type_index = u2()

    def read_info(self, f):
        self.class_index.read(f)
        self.name_and_type_index.read(f)

    def dump(self):
        result = '{\'type\':\'field_ref_info\',\'class_index\':' + str(self.class_index.u2_2int()) + \
                 ',\'name_and_type_index\':' + str(self.name_and_type_index.u2_2int()) + '}'
        return result


class method_ref_info(constant_pool_info):
    def __init__(self, ci=constant_pool_info()):
        constant_pool_info.__init__(self)
        self.tag = ci.tag
        self.class_index = u2()
        self.name_and_type_index = u2()

    def read_info(self, f):
        self.class_index.read(f)
        self.name_and_type_index.read(f)

    def dump(self):
        result = '{\'type\':\'method_ref_info\',\'class_index\':' + str(self.class_index.u2_2int()) + \
                 ',\'name_and_type_index\':' + str(self.name_and_type_index.u2_2int()) + '}'
        return result


class interface_method_ref_info(constant_pool_info):
    def __init__(self, ci=constant_pool_info()):
        constant_pool_info.__init__(self)
        self.tag = ci.tag
        self.class_index = u2()
        self.name_and_type_index = u2()

    def read_info(self, f):
        self.class_index.read(f)
        self.name_and_type_index.read(f)

    def dump(self):
        result = '{\'type\':\'interface_method_ref_inf\', \'class_index\':' + str(self.class_index.u2_2int()) + \
                 ',\'name_and_type_index\':' + str(self.name_and_type_index.u2_2int()) + '}'
        return result


class string_info(constant_pool_info):
    def __init__(self, ci=constant_pool_info()):
        constant_pool_info.__init__(self)
        self.tag = ci.tag
        self.string_index = u2()

    def read_info(self, f):
        self.string_index.read(f)

    def dump(self):
        return '{\'type\':\'string_info\',\'string_index\':' + str(self.string_index.u2_2int()) + '}'


class integer_info(constant_pool_info):
    def __init__(self, ci=constant_pool_info()):
        constant_pool_info.__init__(self)
        self.tag = ci.tag
        self.bytes = u4()

    def read_info(self, f):
        self.bytes.read(f)

    def dump(self):
        return '{\'type\':\'integer_info\',\'bytes\':' + str(self.bytes.u4_2int()) + '}'


class float_info(constant_pool_info):
    def __init__(self, ci=constant_pool_info()):
        constant_pool_info.__init__(self)
        self.tag = ci.tag
        self.bytes = u4()

    def read_info(self, f):
        self.bytes.read(f)

    def dump(self):
        return '{\'type\':\'float_info\',\'bytes\':' + str(self.bytes.u4_2float()) + '}'


class long_info(constant_pool_info):
    def __init__(self, ci=constant_pool_info()):
        constant_pool_info.__init__(self)
        self.tag = ci.tag
        self.high_bytes = u4()
        self.low_bytes = u4()

    def read_info(self, f):
        self.high_bytes.read(f)
        self.low_bytes.read(f)

    def dump(self):
        byte_s = self.high_bytes.value + self.low_bytes.value
        return '{\'type\':\'long_info\',\'bytes\':' + str(struct.unpack('>q', byte_s)[0]) + '}'


class double_info(constant_pool_info):
    def __init__(self, ci=constant_pool_info()):
        constant_pool_info.__init__(self)
        self.tag = ci.tag
        self.high_bytes = u4()
        self.low_bytes = u4()

    def read_info(self, f):
        self.high_bytes.read(f)
        self.low_bytes.read(f)

    def dump(self):
        byte_s = self.high_bytes.value + self.low_bytes.value
        result = '{\'type\':\'double_info\',\'bytes\':' + str(struct.unpack('>d', byte_s)[0]) + '}'
        return result


class name_and_type_info(constant_pool_info):
    def __init__(self, ci=constant_pool_info()):
        constant_pool_info.__init__(self)
        self.tag = ci.tag
        self.name_index = u2()
        self.descriptor_index = u2()

    def read_info(self, f):
        self.name_index.read(f)
        self.descriptor_index.read(f)

    def dump(self):
        result = '{\'type\':\'name_and_type_info\',\'name_index\':' + str(self.name_index.u2_2int()) + \
                 ',\'descriptor_index\':' + str(self.descriptor_index.u2_2int()) + '}'
        return result


class utf8_info(constant_pool_info):
    def __init__(self, ci=constant_pool_info()):
        constant_pool_info.__init__(self)
        self.tag = ci.tag
        self.length = u2()
        self.bytes = un()

    def read_info(self, f):
        self.length.read(f)
        self.bytes.read(f, self.length.u2_2int())

    def dump(self):
        result = '{\'type\':\'utf8_info\',\'length\':' + str(
            self.length.u2_2int()) + ',\'bytes\':\'' + self.bytes.un_2str() + '\'}'
        return result


class method_handle_info(constant_pool_info):
    def __init__(self, ci=constant_pool_info()):
        constant_pool_info.__init__(self)
        self.tag = ci.tag
        self.reference_kind = u1()
        self.reference_index = u2()

    def read_info(self, f):
        self.reference_kind.read(f)
        self.reference_index.read(f)

    def dump(self):
        result = '{\'type\':\'method_handle_info\',\'reference_kind\':' + str(self.reference_kind.u1_2int())
        result += ',\'reference_index\':' + str(self.reference_index.u2_2int()) + '}'
        return result


class method_type_info(constant_pool_info):
    def __init__(self, ci=constant_pool_info()):
        constant_pool_info.__init__(self)
        self.tag = ci.tag
        self.descriptor_index = u2()

    def read_info(self, f):
        self.descriptor_index.read(f)

    def dump(self):
        return '{\'type\':\'method_type_info\',\'descriptor_index\':' + str(self.descriptor_index.u2_2int()) + '}'


class invoke_dynamic_info(constant_pool_info):
    def __init__(self, ci=constant_pool_info()):
        constant_pool_info.__init__(self)
        self.tag = ci.tag
        self.bootstrap_method_attr_index = u2()
        self.name_and_type_index = u2()

    def read_info(self, f):
        self.bootstrap_method_attr_index.read(f)
        self.name_and_type_index.read(f)

    def dump(self):
        result = '{\'type\':\'invoke_dynamic_info\',\'bootstrap_method_attr_index\':' + str(
            self.bootstrap_method_attr_index.u2_2int())
        result += ',\'name_and_type_index\':' + str(self.name_and_type_index.u2_2int()) + '}'
        return result


# ------------------------------------------ access flags ------------------------------------------

class access_flags:
    def __init__(self):
        self.value = u2()

    def read(self, f):
        self.value.read(f)

    def dump(self):
        result = ''

        for name, value in inspect.getmembers(self):
            if 'ACC' in name:  # filter out access_flags
                if self.value.u2_2int() & value == value:
                    result += name
                    result += '|'

        return result.rstrip('|')


class class_access_flags(access_flags):
    ACC_PUBLIC = 0x0001
    ACC_FINAL = 0x0010
    ACC_SUPER = 0x0020
    ACC_INTERFACE = 0x0200
    ACC_ABSTRACT = 0x0400
    ACC_SYNTHETIC = 0x1000
    ACC_ANNOTATION = 0x2000
    ACC_ENUM = 0x4000


class field_access_flags(access_flags):
    ACC_PUBLIC = 0x0001
    ACC_PRIVATE = 0x0002
    ACC_PROTECTED = 0x0004
    ACC_STATIC = 0x0008
    ACC_FINAL = 0x0010
    ACC_VOLATILE = 0x0040
    ACC_TRANSIENT = 0x0080
    ACC_SYNTHETIC = 0x1000
    ACC_ENUM = 0x4000


class method_access_flags(access_flags):
    ACC_PUBLIC = 0x0001
    ACC_PRIVATE = 0x0002
    ACC_PROTECTED = 0x0004
    ACC_STATIC = 0x0008
    ACC_FINAL = 0x0010
    ACC_SYNCHRONIZED = 0x0020
    ACC_BRIDGE = 0x0040
    ACC_VARARGS = 0x0080
    ACC_NATIVE = 0x0100
    ACC_ABSTRACT = 0x0400
    ACC_STRICT = 0x0800
    ACC_SYNTHETIC = 0x1000


# ------------------------------------------ field info ------------------------------------------

class field_info:
    def __init__(self):
        self.access_flags = field_access_flags()
        self.name_index = u2()
        self.descriptor_index = u2()
        self.attributes_count = u2()
        self.attributes = []

    def read(self, f):
        self.access_flags.read(f)
        self.name_index.read(f)
        self.descriptor_index.read(f)
        self.attributes_count.read(f)
        for i in range(0, self.attributes_count.u2_2int()):
            ai = attribute_info()
            ai.read(f)
            self.attributes.append(ai)

    def dump(self):
        result = '{\'type\':\'field_info\''
        result += ',\'access_flags\':' + self.access_flags.dump()
        result += ',\'name_index\':' + str(self.name_index.u2_2int())
        result += ',\'descriptor_index\':' + str(self.descriptor_index.u2_2int())
        result += ',\'attributes_count\':' + str(self.attributes_count.u2_2int())
        result += ',\'attributes\':'
        for attribute in self.attributes:
            result += attribute.dump()
        result += '}'
        return result


# ------------------------------------------ method info ------------------------------------------

class method_info:
    def __init__(self):
        self.access_flags = method_access_flags()
        self.name_index = u2()
        self.descriptor_index = u2()
        self.attributes_count = u2()
        self.attributes = []

    def read(self, f):
        self.access_flags.read(f)
        self.name_index.read(f)
        self.descriptor_index.read(f)
        self.attributes_count.read(f)
        for i in range(0, self.attributes_count.u2_2int()):
            ai = attribute_info()
            ai.read(f)
            self.attributes.append(ai)

    def dump(self):
        result = '{\'type\':\'method_info\''
        result += ',\'access_flags\':' + self.access_flags.dump()
        result += ',\'name_index\':' + str(self.name_index.u2_2int())
        result += ',\'descriptor_index\':' + str(self.descriptor_index.u2_2int())
        result += ',\'attributes_count\':' + str(self.attributes_count.u2_2int())
        result += ',\'attributes\':'
        for attribute in self.attributes:
            result += attribute.dump()
        result += '}'
        return result


# ------------------------------------------ attribute info ------------------------------------------

class attribute_info:
    def __init__(self):
        self.attribute_name_index = u2()
        self.attribute_length = u4()
        self.info = un()

    def read(self, f):
        self.attribute_name_index.read(f)
        self.attribute_length.read(f)
        self.info.read(f, self.attribute_length.u4_2int())

    def dump(self):
        result = "{\'attribute_name_index\':" + str(self.attribute_name_index.u2_2int())
        result += ",\'attribute_length\':" + str(self.attribute_length.u4_2int()) + '}'

        return result


# ------------------------------------------ constant value attribute ------------------------------------------

class constant_value_attribute:
    def __init__(self):
        self.attribute_name_index = u2()
        self.attribute_length = u4()
        self.constant_value_index = u2()

    def read(self, f):
        self.attribute_name_index.read(f)
        self.attribute_length.read(f)
        self.constant_value_index.read(f)


# ------------------------------------------ code attribute - -----------------------------------------

class code_exception:
    def __init__(self):
        self.start_pc = u2()
        self.end_pc = u2()
        self.handler_pc = u2()
        self.catch_type = u2()


class code_attribute:
    def __init__(self):
        self.attribute_name_index = u2()
        self.attribute_length = u4()
        self.max_stack = u2()
        self.max_locals = u2()
        self.code_length = u4()
        # self.code_length长度的u1数组
        self.code = []
        self.exception_table_length = u2()
        self.exception_table = []
        self.attributes_count = u2()
        # attributes_count长度的attribute_info数组
        self.attributes = []


# ------------------------------------------ stack map table attribute ------------------------------------------

class StackMapTable(attribute_info):
    def __init__(self):
        attribute_info.__init__(self)
        self.number_of_entries = u2()
        # stack map frame 数组
        self.entries = []

    def read_info(self, f):
        self.number_of_entries.read(f)
        for i in range(0, self.number_of_entries.u2_2int()):
            break


class stack_map_frame:
    def __init__(self):
        self.frame_type = u1()


class same_frame(stack_map_frame):
    def __init__(self):
        stack_map_frame.__init__(self)


class same_locals_1_stack_item_frame(stack_map_frame):
    def __init__(self):
        stack_map_frame.__init__(self)
        # verification_type_info的长度为1的数组
        self.stack = []


class same_locals_1_stack_item_frame_extended(stack_map_frame):
    def __init__(self):
        stack_map_frame.__init__(self)
        self.offset_delta = u2()
        # verification_type_info的长度为1的数组
        self.stack = []


class chop_frame(stack_map_frame):
    def __init__(self):
        stack_map_frame.__init__(self)
        self.offset_delta = u2()


class same_frame_extended(stack_map_frame):
    def __init__(self):
        stack_map_frame.__init__(self)
        self.offset_delta = u2()

    def read_info(self, f):
        self.offset_delta.read(f)


class append_frame(stack_map_frame):
    def __init__(self):
        stack_map_frame.__init__(self)
        self.offset_delta = u2()
        # frame_type - 251 大小的verification_type_info数组
        self.locals = []

    def read_info(self, f):
        self.offset_delta.read(f)


class full_frame(stack_map_frame):
    def __init__(self):
        stack_map_frame.__init__(self)
        self.offset_delta = u2()
        self.number_of_locals = u2()
        # number_of_locals大小的verification_type_info数组
        self.locals = []
        self.number_of_stack_items = u2()
        # number_of_stack_items大小的verification_type_info数组
        self.stack = []

    def read_info(self, f):
        self.offset_delta.read(f)
        self.number_of_locals.read(f)
        for i in range(0, self.number_of_locals.u2_2int()):
            break

        self.number_of_stack_items.read(f)

        for i in range(0, self.number_of_stack_items.u2_2int()):
            break


# ------------------------------------------ exception attribute ------------------------------------------

class exceptions_class:
    def __init__(self):
        self.inner_class_info_index = u2()
        self.outer_class_info_index = u2()
        self.inner_name_index = u2()
        self.inner_class_access_flags = u2()


class exceptions_attribute:
    def __init__(self):
        self.attribute_name_index = u2()
        self.attribute_length = u4()
        self.number_of_exceptions = u2()
        # 长度为number_of_exceptions的u2数组
        self.exception_index_table = []
        self.classes = []


# ------------------------------------------ inner classes attribute ------------------------------------------

class inner_classes_attribute:
    def __init__(self):
        self.attribute_name_index = u2()
        self.attribute_length = u4()
        self.number_of_classes = u2()


# ------------------------------------------ enclosing method attribute ------------------------------------------

class enclosing_method_attribute:
    def __init__(self):
        self.attribute_name_index = u2()
        self.attribute_length = u4()
        self.class_index = u2()
        self.method_index = u2()


# ------------------------------------------ synthetic attribute ------------------------------------------

class synthetic_attribute:
    def __init__(self):
        self.attribute_name_index = u2()
        self.attribute_length = u4()


# ------------------------------------------ signature attribute ------------------------------------------

class signature_attribute:
    def __init__(self):
        self.attribute_name_index = u2()
        self.attribute_length = u4()
        self.signature_index = u2()


# ------------------------------------------ source file attribute ------------------------------------------

class source_file_attribute:
    def __init__(self):
        self.attribute_name_index = u2()
        self.attribute_length = u4()
        self.sourcefile_index = u2()


# ------------------------------------------ source debug extension attribute ------------------------------------------

class source_debug_extension_attribute:
    def __init__(self):
        self.attribute_name_index = u2()
        self.attribute_length = u4()
        # 长度为attribute_length的u1数组
        self.debug_extension = []


# ------------------------------------------ line number table attribute ------------------------------------------

class line_number:
    def __init__(self):
        self.start_pc = u2()
        self.line_number = u2()


class line_number_table_attribute:
    def __init__(self):
        self.attribute_name_index = u2()
        self.attribute_length = u4()
        self.line_number_table_length = u2()
        # 长度为line_number_table_length的line_number数组
        self.line_number_table = []


# ------------------------------------------ local variable table attribute ------------------------------------------

class local_variable:
    def __init__(self):
        self.start_pc = u2()
        self.length = u2()
        self.name_index = u2()
        self.descriptor_index = u2()
        self.index = u2()


class local_variable_table_attribute:
    def __init__(self):
        self.attribute_name_index = u2()
        self.attribute_length = u4()
        self.local_variable_table_length = u2()
        # 长度为local_variable_table_length的local_variable数组
        self.local_variable_table = []


# ------------------------------------------ local variable type table attribute ---------------------------------------

class local_variable_type:
    def __init__(self):
        self.start_pc = u2()
        self.length = u2()
        self.name_index = u2()
        self.signature_index = u2()
        self.index = u2()


class local_variable_type_table_attribute:
    def __init__(self):
        self.attribute_name_index = u2()
        self.attribute_length = u4()
        self.local_variable_type_table_length = u2()
        # 长度为local_variable_type_table_length的local_variable_type的数组
        self.local_variable_type_table = []


# ------------------------------------------ deprecated attribute ------------------------------------------

class deprecated_attribute:
    def __init__(self):
        self.attribute_name_index = u2()
        self.attribute_length = u4()


# ------------------------------------------ attribute ------------------------------------------

class constant_value_index:
    def __init__(self):
        self.value = u2()

    def read(self, f):
        self.value.read(f)


class annotation_value:
    def __init__(self):
        self.value = annotation()

    def read(self, f):
        self.value.read(f)


class enum_const_value:
    def __init__(self):
        self.type_name_index = u2()
        self.const_name_index = u2()

    def read(self, f):
        self.type_name_index.read(f)
        self.const_name_index.read(f)


class class_info_index:
    def __init__(self):
        self.value = u2()

    def read(self, f):
        self.value.read(f)


class array_value:
    def __init__(self):
        self.num_values = u2()
        self.values = []  # element_value 数组

    def read(self, f):
        self.num_values.read(f)
        pass


class element_value:
    def __init__(self):
        self.tag = u1()
        self.value = None

    def read(self, f):
        self.tag.read(f)
        if self.tag.u1_2int() == 'B' \
                or self.tag.u1_2char() == 'C' \
                or self.tag.u1_2char() == 'D' \
                or self.tag.u1_2char() == 'F' \
                or self.tag.u1_2char() == 'I' \
                or self.tag.u1_2char() == 'J' \
                or self.tag.u1_2char() == 'S' \
                or self.tag.u1_2char() == 'Z' \
                or self.tag.u1_2char() == 's':
            self.value = constant_value_index()
            self.value.read(f)

        if self.tag.u1_2int() == 'e':
            self.value = enum_const_value()
            self.value.read(f)

        if self.tag.u1_2int() == 'c':
            self.value = class_info_index()
            self.value.read(f)

        if self.tag.u1_2int() == '@':
            self.value = annotation_value()
            self.value.read(f)

        if self.tag.u1_2int() == '[':
            self.value = array_value()
            self.value.read(f)


class element_value_pair:
    def __init__(self):
        self.element_name_index = u2()
        self.value = element_value()

    def read(self, f):
        self.element_name_index.read(f)
        self.value.read(f)


class annotation:
    def __init__(self):
        self.type_index = u2()
        self.num_element_value_pairs = u2()
        # 长度为num_element_value_pairs的element_value_pair数组
        self.element_value_pairs = []

    def read(self, f):
        self.type_index.read(f)
        self.num_element_value_pairs.read(f)
        for i in range(0, self.num_element_value_pairs.u2_2int()):
            self.element_value_pairs.append('')


class runtime_visible_annotation_attribute:
    def __init__(self):
        self.attribute_name_index = u2()
        self.attribute_length = u4()
        self.num_annotations = u2()
        # 长度为num_annotation的annotation数组
        self.annotations = []

    def read(self, f):
        self.attribute_name_index.read(f)
        self.attribute_length.read(f)
        self.num_annotations.read(f)
        self.annotations = [annotation() for _ in range(0, self.num_annotations.u2_2int())]
        for i in range(self.num_annotations.u2_2int()):
            self.annotations[i].read(f)


# ------------------------------------------ runtime invisible annotation attribute ------------------------------------

class runtime_invisible_annotation_attribute:
    def __init__(self):
        self.attribute_name_index = u2()
        self.attribute_length = u4()
        self.num_annotations = u2()
        self.annotations = []

    def read(self, f):
        self.attribute_name_index.read(f)
        self.attribute_length.read(f)
        self.num_annotations.read(f)
        self.annotations = [annotation() for _ in range(0, self.num_annotations.u2_2int())]
        for i in range(self.num_annotations.u2_2int()):
            self.annotations[i].read(f)


# ------------------------------------------ runtime visible parameter annotation attribute ----------------------------

class parameter_annotation:
    def __init__(self):
        self.num_annotations = u2()
        self.annotations = []

    def read(self, f):
        self.num_annotations.read(f)
        self.annotations = [annotation() for _ in range(0, self.num_annotations.u2_2int())]
        for a in self.annotations:
            a.read(f)


class runtime_visible_parameter_annotation_attribute:
    def __init__(self):
        self.attribute_name_index = u2()
        self.attribute_length = u4()
        self.num_parameters = u1()
        self.parameter_annotations = []

    def read(self, f):
        self.attribute_name_index.read(f)
        self.attribute_length.read(f)
        self.num_parameters.read(f)
        self.parameter_annotations = [parameter_annotation() for _ in range(0, self.num_parameters.u1_2int())]
        for pa in self.parameter_annotations:
            pa.read(f)


# ------------------------------------------ runtime invisible parameter annotation attribute --------------------------

class runtime_invisible_parameter_annotation_attribute:
    def __init__(self):
        self.attribute_name_index = u2()
        self.attribute_length = u4()
        self.num_parameters = u1()
        self.parameter_annotations = []

    def read(self, f):
        self.attribute_name_index.read(f)
        self.attribute_length.read(f)
        self.num_parameters.read(f)
        self.parameter_annotations = [parameter_annotation() for _ in range(self.num_parameters.u1_2int())]
        for pa in self.parameter_annotations:
            pa.read(f)


# ------------------------------------------ runtime visible type annotation attribute ---------------------------------

class type_parameter_target:
    def __init__(self):
        self.type_parameter_index = u1()

    def read(self, f):
        self.type_parameter_index.read(f)


class supertype_target:
    def __init__(self):
        self.supertype_index = u2()

    def read(self, f):
        self.supertype_index.read(f)


class type_parameter_bound_target:
    def __init__(self):
        self.type_parameter_index = u1()
        self.bound_index = u1()

    def read(self, f):
        self.type_parameter_index.read(f)
        self.bound_index.read(f)


class empty_target:
    def __init__(self):
        pass


class formal_parameter_target:
    def __init__(self):
        self.formal_parameter_index = u1()

    def read(self, f):
        self.formal_parameter_index.read(f)


class throws_target:
    def __init__(self):
        self.throws_type_index = u2()

    def read(self, f):
        self.throws_type_index.read(f)


class type_annotation:
    def __init__(self):
        self.target_type = u1()
        # self


class runtime_visible_type_annotations_attribute:
    def __init__(self):
        self.attribute_name_index = u2()
        self.attribute_length = u4()
        self.num_annotations = u1()
        self.annotations = []

    def read(self, f):
        self.attribute_name_index.read(f)
        self.attribute_length.read(f)
        self.num_annotations.read(f)
        self.annotations = [annotation() for _ in range(0, self.num_annotations.u1_2int())]
        for pa in self.annotations:
            pa.read(f)


# ------------------------------------------ InfoHolder ------------------------------------------

class InfoHolder:
    """
    hold info for later processing
    """

    def __init__(self):
        self.magic = None
        self.minor_version = None
        self.major_version = None
        self.constant_pool = dict()  # only store constant pool info
        self.access_flags = None
        self.this_class = None
        self.super_class = None
        self.interfaces = []
        self.fields = []
        self.methods = []
        self.attributes = []

    def parse(self):
        """
        do some query stuff, like index parsing
        :return:
        """
        pass

    def dump(self):
        for m in list(self.constant_pool.items()):
            print(m[0], m[1].dump())
        print(self.access_flags)
        print(self.this_class)
        print(self.super_class)
        for interface in self.interfaces:
            print(interface)
        for field in self.fields:
            print(field)
        for method in self.methods:
            print(method)
        for attribute in self.attributes:
            print(attribute)


# ------------------------------------------ JavaClass ------------------------------------------------

class JavaClass:
    """
    Represent Java Class
    """

    def __init__(self):
        self.magic = u4()
        self.minor_version = u2()
        self.major_version = u2()
        self.constant_pool_count = u2()
        self.constant_pool = []
        self.access_flags = class_access_flags()
        self.this_class = u2()
        self.super_class = u2()
        self.interfaces_count = u2()
        self.interfaces = []
        self.fields_count = u2()
        self.fields = []
        self.methods_count = u2()
        self.methods = []
        self.attributes_count = u2()
        self.attributes = []


# ------------------------------------------ JavaClassReader ------------------------------------------

class JavaClassReader:
    def __init__(self):
        self.output = InfoHolder()
        # divider
        self.java_class = JavaClass()

    def read_magic(self, f):
        """
        读取魔数
        :param f:
        :return:
        """
        self.java_class.magic.read(f)

    def read_minor_version(self, f):
        """
        读取minor version信息
        :param f:
        :return:
        """
        self.java_class.minor_version.read(f)

    def read_major_version(self, f):
        """
        读取major version信息
        :param f:
        :return:
        """
        self.java_class.major_version.read(f)

    def read_constant_pool(self, f):
        """
        读取常量池信息
        :param f:
        :return:
        """
        self.java_class.constant_pool_count.read(f)
        self.java_class.constant_pool = []
        # https://stackoverflow.com/questions/41176545/the-constant-pool-lost-3-in-class-file
        need_to_skip = False
        for i in range(1, self.java_class.constant_pool_count.u2_2int()):
            if need_to_skip:
                need_to_skip = False
                continue
            ci = constant_pool_info()
            ci.read(f)
            if ci.is_class():
                ci_e = class_info(ci)
            elif ci.is_field_ref():
                ci_e = field_ref_info(ci)
            elif ci.is_method_ref():
                ci_e = method_ref_info(ci)
            elif ci.is_interface_method_ref():
                ci_e = interface_method_ref_info(ci)
            elif ci.is_string():
                ci_e = string_info(ci)
            elif ci.is_integer():
                ci_e = integer_info(ci)
            elif ci.is_float():
                ci_e = float_info(ci)
            elif ci.is_long():
                need_to_skip = True
                ci_e = long_info(ci)
            elif ci.is_double():
                need_to_skip = True
                ci_e = double_info(ci)
            elif ci.is_name_and_type():
                ci_e = name_and_type_info(ci)
            elif ci.is_utf8():
                ci_e = utf8_info(ci)
            elif ci.is_method_handle():
                ci_e = method_handle_info(ci)
            elif ci.is_method_type():
                ci_e = method_type_info(ci)
            elif ci.is_invoke_dynamic():
                ci_e = invoke_dynamic_info(ci)
            else:
                raise RuntimeError("unknown stuff in constant pool")

            if ci_e is not None:
                ci_e.read_info(f)
                self.output.constant_pool[i] = ci_e

    def read_access_flags(self, f):
        """
        读取类的访问标识符
        :param f:
        :return:
        """
        self.java_class.access_flags.read(f)
        self.output.access_flags = "{\"access_flags\": \"" + str(self.java_class.access_flags.dump() + "\"}")

    def read_this_class(self, f):
        """
        读取this类信息
        :param f:
        :return:
        """
        self.java_class.this_class.read(f)
        self.output.this_class = "{\"this_class\": " + str(
            self.java_class.this_class.u2_2int()) + ", \"class_name\": \"" \
                                 + self.output.constant_pool[self.output.constant_pool[
            self.java_class.this_class.u2_2int()].name_index.u2_2int()].bytes.un_2str() + "\"}"

    def read_super_class(self, f):
        """
        读取super类信息
        :param f:
        :return:
        """
        try:
            self.java_class.super_class.read(f)
            self.output.super_class = "{\"super_class\": " + str(self.java_class.super_class.u2_2int()) + \
                                      ", \"class_name\": \"" + self.output.constant_pool[self.output.constant_pool[
                self.java_class.super_class.u2_2int()].name_index.u2_2int()].bytes.un_2str() + "\"}"
        except KeyError:
            pass

    def read_interfaces(self, f):
        """
        读取接口信息
        :param f:
        :return:
        """
        self.java_class.interfaces_count.read(f)
        for i in range(0, self.java_class.interfaces_count.u2_2int()):
            interface = u2()
            interface.read(f)
            self.java_class.interfaces.append(interface)
            self.output.interfaces.append(
                "{\"interface\": \"" + str(interface.u2_2int()) + ", \"class_name\": \"" + self.output.constant_pool[
                    self.output.constant_pool[interface.u2_2int()].name_index.u2_2int()].bytes.un_2str() + "\"}")

    def read_fields(self, f):
        """
        读取字段信息
        :param f:
        :return:
        """
        self.java_class.fields_count.read(f)
        for i in range(0, self.java_class.fields_count.u2_2int()):
            fi = field_info()
            fi.read(f)
            self.output.fields.append(fi.dump())

    def read_methods(self, f):
        """
        读取方法信息
        :param f:
        :return:
        """
        self.java_class.methods_count.read(f)
        for i in range(0, self.java_class.methods_count.u2_2int()):
            mi = method_info()
            mi.read(f)
            self.output.methods.append(mi.dump())

    def read_attributes(self, f):
        """
        读取属性信息
        :param f:
        :return:
        """
        self.java_class.attributes_count.read(f)
        for i in range(0, self.java_class.attributes_count.u2_2int()):
            ai = attribute_info()
            ai.read(f)
            self.java_class.attributes.append(ai)
            self.output.attributes.append(ai.dump())

    def read(self, f):
        """
        具体的读取过程
        :param f:
        :return:
        """
        Profiler.begin()
        self.read_magic(f)
        Profiler.end('read_magic')

        Profiler.begin()
        self.read_minor_version(f)
        Profiler.end('read_minor_version')

        Profiler.begin()
        self.read_major_version(f)
        Profiler.end('read_major_version')

        Profiler.begin()
        self.read_constant_pool(f)
        Profiler.end('read_constant_pool')

        Profiler.begin()
        self.read_access_flags(f)
        Profiler.end('read_access_flags')

        Profiler.begin()
        self.read_this_class(f)
        Profiler.end('read_this_class')

        Profiler.begin()
        self.read_super_class(f)
        Profiler.end('read_super_class')

        Profiler.begin()
        self.read_interfaces(f)
        Profiler.end('read_interfaces')

        Profiler.begin()
        self.read_fields(f)
        Profiler.end('read_fields')

        Profiler.begin()
        self.read_methods(f)
        Profiler.end('read_methods')

        Profiler.begin()
        self.read_attributes(f)
        Profiler.end('read_attributes')


# ------------------------------------------ Processor ------------------------------------------

class Processor:
    def __init__(self):
        pass

    @staticmethod
    def search_constant_pool(content, matcher):
        for info in list(content.values()):
            if info.search(matcher):
                print(info.dump())
                return True
        return False

    @staticmethod
    def _process_class_file(options, path, matcher):
        """
        when path is normal class file
        :param path:
        :param matcher:
        :return:
        """
        f = open(path, 'rb')  # open as a binary file
        callback = lambda: print(path)
        Processor._process(options, f, matcher, callback)

    @staticmethod
    def _process(options, f, matcher, callback):
        reader = JavaClassReader()
        reader.read(f)
        if options.dump:
            reader.output.dump()
        else:
            if Processor.search_constant_pool(reader.output.constant_pool, matcher):
                callback()

    @staticmethod
    def _process_zip_file_with_threading(options, path, matcher):
        f = zipfile.ZipFile(path)

        import threading

        if PY2:
            import Queue as q

        if PY3:
            import queue as q

        def do_work(in_queue, out_queue):
            while True:
                member = in_queue.get()
                member_file = f.open(member)
                callback = lambda: print(member)
                result = Processor._process(options, member_file, matcher, callback)
                member_file.close()
                out_queue.put(result)
                in_queue.task_done()

        work_queue = q.Queue()
        results = q.Queue()

        # start for workers
        for i in range(2):
            t = threading.Thread(target=do_work, args=(work_queue, results))
            t.daemon = True
            t.start()

        # produce data
        for member in f.namelist():
            if (Processor._is_class_file(member)):
                work_queue.put(member)

        work_queue.join()
        f.close()

    @staticmethod
    def process(options=None, path=None, matcher=None):
        """
        入口函数
        :param path:
        :param matcher:
        :return:
        """
        if zipfile.is_zipfile(path):
            Processor._process_zip_file_with_threading(options, path, matcher)
        else:
            if Processor._is_class_file(path):
                Processor._process_class_file(options, path, matcher)

    @staticmethod
    def dump_by_file_pattern(path, file_pattern):
        """
        dump指定文件
        :param path:
        :param file_pattern:
        :return:
        """
        if zipfile.is_zipfile(path):
            with zipfile.ZipFile(path) as z:
                for member in z.namelist():
                    if file_pattern in member:
                        output_file = open('./' + Processor._generate_class_name(member), 'wr')
                        output_file.write(z.open(member, 'r').read())

    @staticmethod
    def _generate_class_name(member):
        """
        convert x/x/x/x.class to x_x_x_x.class
        :param member:
        :return:
        """
        return member.replace('/', '_')

    @staticmethod
    def _is_class_file(name):
        """
        here we only using file name, later
        :param name:
        :return:
        """
        if name.endswith('.class'):
            return True
        return False


# ------------------------------------------ parse cmd ------------------------------------------

def _parse_cmdline(cmdline_args):
    """ Parse the list of command-line options and arguments and return a
        triple: options, args, parser -- the first two being the result of
        OptionParser.parse_args, and the third the parser object itself.`
    """
    parser = argparse.ArgumentParser(
        usage='usage: %(prog)s [options] <jar file> <pattern>',
        description='',
        prog='JarGrep',
        add_help=False)

    parser.add_argument('-h', '--help',
                        action='store_true', dest='help', default=False,
                        help='Display this information')

    parser.add_argument('-b', "--benchmarking",
                        action='store_true', dest='benchmark', default=False,
                        help='Turn on benchmarking mode')

    parser.add_argument('-v', '--verbose',
                        action='store_true', dest='verbose', default=False,
                        help='Turn on verbose mode')

    parser.add_argument('-d', '--dump',
                        action='store_true', dest='dump', default=False,
                        help='dump the specified file to the current directory')

    options, args = parser.parse_known_args(cmdline_args)

    return options, args, parser


# ------------------------------------------ benchmark ------------------------------------------

class Profiler:
    is_on = False

    start_time = 0
    end_time = 0

    def __init__(self):
        pass

    @staticmethod
    def on():
        Profiler.is_on = True

    @staticmethod
    def off():
        Profiler.is_on = False

    @staticmethod
    def _current_time_in_millisecond():
        import time
        second = int(round(time.time() * 1000))
        return second

    @staticmethod
    def begin():
        if Profiler.is_on:
            Profiler.start_time = Profiler._current_time_in_millisecond()

    @staticmethod
    def end(tag=""):
        if Profiler.is_on:
            Profiler.end_time = Profiler._current_time_in_millisecond()
            print(tag + "totally consumed " + str(Profiler.end_time - Profiler.start_time) + " milliseconds")


# ------------------------------------------ Log ------------------------------------------

class Logger:
    is_on = False

    def __init__(self):
        pass

    @staticmethod
    def on():
        Logger.is_on = True

    @staticmethod
    def off():
        Logger.is_on = False

    @staticmethod
    def log(content=''):
        if Logger.is_on:
            print(content)


def _parallel_process(options, matcher, directory):
    from pathos import multiprocessing as mp
    pool = mp.Pool(mp.cpu_count())
    from scandir import scandir, walk
    import pickle

    def processFilepath(dir_entry):
        try:
            if dir_entry['is_dir']:
                for (dirpath, dirnames, filenames) in walk(dir_entry['name']):
                    for filename in filenames:
                        if filename.endswith('.jar'):
                            filepath = os.path.join(dirpath, filename)
                            if os.stat(filepath).st_size == 0:
                                continue
                            try:
                                Processor.process(options, filepath, matcher)
                            except:
                                return filepath
            else:
                try:
                    Processor.process(options, dir_entry['path'], matcher)
                except:
                    return dir_entry['path']
        except:
            pass

    def _generateFilepaths(d):
        for entry in scandir(d):
            if entry.is_dir(follow_symlinks=False):
                for inner_entry in _generateFilepaths(entry.path):
                    yield inner_entry
            else:
                yield entry

    def generateFilepaths():
        for entry in _generateFilepaths(directory):
            st = entry.stat(follow_symlinks=False)
            st_ = {'st_mode': st.st_mode, 'st_size': st.st_size, \
                   'st_atime': st.st_atime, 'st_mtime': st.st_mtime, \
                   'st_ctime': st.st_ctime}
            # now convert the entry object to entry_
            entry_ = {'name': entry.name, 'is_dir': entry.is_dir(follow_symlinks=False), \
                      'path': entry.path, 'stat': st_}
            yield entry_

    try:
        chunk_size = 4  # For very long iterables using a large value for chunksize can make the job complete much faster than using the default value of 1.
        for result in pool.imap(processFilepath, generateFilepaths(), chunk_size):
            if result is not None:
                print(result)
        pool.close()
    except KeyboardInterrupt:
        pool.terminate()
    except RuntimeError:
        pool.terminate()


# ------------------------------------------ main ------------------------------------------
def main(argv):
    options, args, parser = _parse_cmdline(argv)

    if options.verbose:
        print(args)

    path = args[1]
    pattern = args[2]

    if path is None or pattern is None:
        return
    matcher = ContentMatcher(pattern)

    if not os.path.exists(path):
        print(path + " not exist")
        return

    if options.benchmark:
        Profiler.on()
        Profiler.begin()

    if os.path.isdir(path):
        _parallel_process(options, matcher, path)
    else:
        Processor.process(options, path, matcher)

    if options.benchmark:
        Profiler.end()


sys.exit(main(sys.argv))

