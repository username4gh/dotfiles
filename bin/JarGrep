#! /usr/bin/env python
# coding=utf-8

# /path/to/openjdk/jdk/src/java.base/share/classes/java/io/DataInputStream.java
from __future__ import print_function
import cStringIO
import inspect
import argparse
import os
import struct
import sys
import zipfile


# --- basic type
# here we assume the endian-ess of class file is big-endian

class u:
    def __init__(self):
        self.value = None

    def u2str(self):
        return self.value


class u1(u):
    def __init__(self):
        u.__init__(self)

    def u2int(self):
        # read() will set self.value to utf-8 code in string
        return struct.unpack(">B", self.value)[0]

    def u2char(self):
        return struct.unpack(">c", self.value)

    def read(self, f):
        self.value = f.read(1)


class u2(u):
    def __init__(self):
        u.__init__(self)

    def u2int(self):
        # read() will set self.value to utf-8 code in string
        return struct.unpack(">H", self.value)[0]

    def read(self, f):
        self.value = f.read(2)


class u4(u):
    def __init__(self):
        u.__init__(self)

    def u2int(self):
        return struct.unpack(">I", self.value)[0]

    def read(self, f):
        self.value = f.read(4)


class un(u):
    def __init__(self):
        u.__init__(self)

    def read(self, f, n):
        self.value = f.read(n)


# ------------------------------------------ constant pool ------------------------------------------

class cp_info:
    def __init__(self):
        self.tag = u1()

    def read(self, f):
        self.tag.read(f)

    def search(self, pattern):
        if pattern is None:
            # for pattern be empty, just return true
            return True
        if pattern in self.dump():
            return True
        return False

    def dump(self):
        pass

    def is_class(self):
        if self.tag.u2int() == 7:
            return True
        else:
            return False

    def is_field_ref(self):
        if self.tag.u2int() == 9:
            return True
        else:
            return False

    def is_method_ref(self):
        if self.tag.u2int() == 10:
            return True
        else:
            return False

    def is_interface_method_ref(self):
        if self.tag.u2int() == 11:
            return True
        else:
            return False

    def is_string(self):
        if self.tag.u2int() == 8:
            return True
        else:
            return False

    def is_integer(self):
        if self.tag.u2int() == 3:
            return True
        else:
            return False

    def is_float(self):
        if self.tag.u2int() == 4:
            return True
        else:
            return False

    def is_long(self):
        if self.tag.u2int() == 5:
            return True
        else:
            return False

    def is_double(self):
        if self.tag.u2int() == 6:
            return True
        else:
            return False

    def is_name_and_type(self):
        if self.tag.u2int() == 12:
            return True
        else:
            return False

    def is_utf8(self):
        if self.tag.u2int() == 1:
            return True
        else:
            return False

    def is_method_handle(self):
        if self.tag.u2int() == 15:
            return True
        else:
            return False

    def is_method_type(self):
        if self.tag.u2int() == 16:
            return True
        else:
            return False

    def is_invoke_dynamic(self):
        if self.tag.u2int() == 18:
            return True
        else:
            return False


class class_info(cp_info):
    def __init__(self, ci=cp_info()):
        cp_info.__init__(self)
        self.tag = ci.tag
        self.name_index = u2()

    def read_info(self, f):
        self.name_index.read(f)

    def dump(self):
        return '{\'type\':\'class_info\',\'name_index\':' + str(self.name_index.u2int()) + '}'


class field_ref_info(cp_info):
    def __init__(self, ci=cp_info()):
        cp_info.__init__(self)
        self.tag = ci.tag
        self.class_index = u2()
        self.name_and_type_index = u2()

    def read_info(self, f):
        self.class_index.read(f)
        self.name_and_type_index.read(f)

    def dump(self):
        result = '{\'type\':\'field_ref_info\',\'class_index\':' + str(self.class_index.u2int()) + \
                 ',\'name_and_type_index\':' + str(self.name_and_type_index.u2int()) + '}'
        return result


class method_ref_info(cp_info):
    def __init__(self, ci=cp_info()):
        cp_info.__init__(self)
        self.tag = ci.tag
        self.class_index = u2()
        self.name_and_type_index = u2()

    def read_info(self, f):
        self.class_index.read(f)
        self.name_and_type_index.read(f)

    def dump(self):
        result = '{\'type\':\'method_ref_info\',\'class_index\':' + str(self.class_index.u2int()) + \
                 ',\'name_and_type_index\':' + str(self.name_and_type_index.u2int()) + '}'
        return result


class interface_method_ref_info(cp_info):
    def __init__(self, ci=cp_info()):
        cp_info.__init__(self)
        self.tag = ci.tag
        self.class_index = u2()
        self.name_and_type_index = u2()

    def read_info(self, f):
        self.class_index.read(f)
        self.name_and_type_index.read(f)

    def dump(self):
        result = '{\'type\':\'interface_method_ref_inf\', \'class_index\':' + str(self.class_index.u2int()) + \
                 ',\'name_and_type_index\':' + str(self.name_and_type_index.u2int()) + '}'
        return result


class string_info(cp_info):
    def __init__(self, ci=cp_info()):
        cp_info.__init__(self)
        self.tag = ci.tag
        self.string_index = u2()

    def read_info(self, f):
        self.string_index.read(f)

    def dump(self):
        return '{\'type\':\'string_info\',\'string_index\':' + str(self.string_index.u2int()) + '}'


class integer_info(cp_info):
    def __init__(self, ci=cp_info()):
        cp_info.__init__(self)
        self.tag = ci.tag
        self.bytes = u4()

    def read_info(self, f):
        self.bytes.read(f)

    def dump(self):
        return '{\'type\':\'integer_info\',\'bytes\':' + str(self.bytes.u2int()) + '}'


class float_info(cp_info):
    def __init__(self, ci=cp_info()):
        cp_info.__init__(self)
        self.tag = ci.tag
        self.bytes = u4()

    def read_info(self, f):
        self.bytes.read(f)

    def dump(self):
        return '{\'type\':\'float_info\',\'bytes\':' + str(struct.unpack(">f", self.bytes.value)[0]) + '}'


class long_info(cp_info):
    def __init__(self, ci=cp_info()):
        cp_info.__init__(self)
        self.tag = ci.tag
        self.high_bytes = u4()
        self.low_bytes = u4()

    def read_info(self, f):
        self.high_bytes.read(f)
        self.low_bytes.read(f)

    def dump(self):
        byte_s = self.high_bytes.value + self.low_bytes.value
        return '{\'type\':\'long_info\',\'bytes\':' + str(struct.unpack('>q', byte_s)[0]) + '}'


class double_info(cp_info):
    def __init__(self, ci=cp_info()):
        cp_info.__init__(self)
        self.tag = ci.tag
        self.high_bytes = u4()
        self.low_bytes = u4()

    def read_info(self, f):
        self.high_bytes.read(f)
        self.low_bytes.read(f)

    def dump(self):
        byte_s = self.high_bytes.value + self.low_bytes.value
        result = '{\'type\':\'double_info\',\'bytes\':' + str(struct.unpack('>q', byte_s)[0]) + '}'
        return result


class name_and_type_info(cp_info):
    def __init__(self, ci=cp_info()):
        cp_info.__init__(self)
        self.tag = ci.tag
        self.name_index = u2()
        self.descriptor_index = u2()

    def read_info(self, f):
        self.name_index.read(f)
        self.descriptor_index.read(f)

    def dump(self):
        result = '{\'type\':\'name_and_type_info\',\'name_index\':' + str(self.name_index.u2int()) + \
                 ',\'descriptor_index\':' + str(self.descriptor_index.u2int()) + '}'
        return result


class utf8_info(cp_info):
    def __init__(self, ci=cp_info()):
        cp_info.__init__(self)
        self.tag = ci.tag
        self.length = u2()
        self.bytes = un()

    def read_info(self, f):
        self.length.read(f)
        self.bytes.read(f, self.length.u2int())

    def dump(self):
        result = '{\'type\':\'utf8_info\',\'length\':' + str(
            self.length.u2int()) + ',\'bytes\':\'' + self.bytes.u2str() + '\'}'
        return result


class method_handle_info(cp_info):
    def __init__(self, ci=cp_info()):
        cp_info.__init__(self)
        self.tag = ci.tag
        self.reference_kind = u1()
        self.reference_index = u2()

    def read_info(self, f):
        self.reference_kind.read(f)
        self.reference_index.read(f)

    def dump(self):
        result = '{\'type\':\'method_handle_info\',\'reference_kind\':' + str(self.reference_kind.u2int())
        result += ',\'reference_index\':' + str(self.reference_index.u2int()) + '}'
        return result


class method_type_info(cp_info):
    def __init__(self, ci=cp_info()):
        cp_info.__init__(self)
        self.tag = ci.tag
        self.descriptor_index = u2()

    def read_info(self, f):
        self.descriptor_index.read(f)

    def dump(self):
        return '{\'type\':\'method_type_info\',\'descriptor_index\':' + str(self.descriptor_index.u2int()) + '}'


class invoke_dynamic_info(cp_info):
    def __init__(self, ci=cp_info()):
        cp_info.__init__(self)
        self.tag = ci.tag
        self.bootstrap_method_attr_index = u2()
        self.name_and_type_index = u2()

    def read_info(self, f):
        self.bootstrap_method_attr_index.read(f)
        self.name_and_type_index.read(f)

    def dump(self):
        result = '{\'type\':\'invoke_dynamic_info\',\'bootstrap_method_attr_index\':' + str(
            self.bootstrap_method_attr_index.u2int())
        result += ',\'name_and_type_index\':' + str(self.name_and_type_index.u2int()) + '}'
        return result


# ------------------------------------------ access flags ------------------------------------------

class access_flags:
    def __init__(self):
        self.value = u2()

    def read(self, f):
        self.value.read(f)

    def dump(self):
        result = ''

        for name, value in inspect.getmembers(self):
            if 'ACC' in name:  # filter out access_flags
                if self.value.u2int() & value == value:
                    result += name
                    result += '|'

        return result.rstrip('|')


class class_access_flags(access_flags):
    ACC_PUBLIC = 0x0001
    ACC_FINAL = 0x0010
    ACC_SUPER = 0x0020
    ACC_INTERFACE = 0x0200
    ACC_ABSTRACT = 0x0400
    ACC_SYNTHETIC = 0x1000
    ACC_ANNOTATION = 0x2000
    ACC_ENUM = 0x4000


class field_access_flags(access_flags):
    ACC_PUBLIC = 0x0001
    ACC_PRIVATE = 0x0002
    ACC_PROTECTED = 0x0004
    ACC_STATIC = 0x0008
    ACC_FINAL = 0x0010
    ACC_VOLATILE = 0x0040
    ACC_TRANSIENT = 0x0080
    ACC_SYNTHETIC = 0x1000
    ACC_ENUM = 0x4000


class method_access_flags(access_flags):
    ACC_PUBLIC = 0x0001
    ACC_PRIVATE = 0x0002
    ACC_PROTECTED = 0x0004
    ACC_STATIC = 0x0008
    ACC_FINAL = 0x0010
    ACC_SYNCHRONIZED = 0x0020
    ACC_BRIDGE = 0x0040
    ACC_VARARGS = 0x0080
    ACC_NATIVE = 0x0100
    ACC_ABSTRACT = 0x0400
    ACC_STRICT = 0x0800
    ACC_SYNTHETIC = 0x1000


# ------------------------------------------ field info ------------------------------------------

class field_info:
    def __init__(self):
        self.access_flags = field_access_flags()
        self.name_index = u2()
        self.descriptor_index = u2()
        self.attributes_count = u2()
        self.attributes = []

    def read(self, f):
        self.access_flags.read(f)
        self.name_index.read(f)
        self.descriptor_index.read(f)
        self.attributes_count.read(f)
        for i in range(0, self.attributes_count.u2int()):
            ai = attribute_info()
            ai.read(f)
            self.attributes.append(ai)

    def dump(self):
        result = '{\'type\':\'field_info\''
        result += ',\'access_flags\':' + self.access_flags.dump()
        result += ',\'name_index\':' + str(self.name_index.u2int())
        result += ',\'descriptor_index\':' + str(self.descriptor_index.u2int())
        result += ',\'attributes_count\':' + str(self.attributes_count.u2int())
        result += ',\'attributes\':'
        for attribute in self.attributes:
            result += attribute.dump()
        result += '}'
        return result


# ------------------------------------------ method info ------------------------------------------

class method_info:
    def __init__(self):
        self.access_flags = method_access_flags()
        self.name_index = u2()
        self.descriptor_index = u2()
        self.attributes_count = u2()
        self.attributes = []

    def read(self, f):
        self.access_flags.read(f)
        self.name_index.read(f)
        self.descriptor_index.read(f)
        self.attributes_count.read(f)
        for i in range(0, self.attributes_count.u2int()):
            ai = attribute_info()
            ai.read(f)
            self.attributes.append(ai)

    def dump(self):
        result = '{\'type\':\'method_info\''
        result += ',\'access_flags\':' + self.access_flags.dump()
        result += ',\'name_index\':' + str(self.name_index.u2int())
        result += ',\'descriptor_index\':' + str(self.descriptor_index.u2int())
        result += ',\'attributes_count\':' + str(self.attributes_count.u2int())
        result += ',\'attributes\':'
        for attribute in self.attributes:
            result += attribute.dump()
        result += '}'
        return result


# ------------------------------------------ attribute info ------------------------------------------

class attribute_info:
    def __init__(self):
        self.attribute_name_index = u2()
        self.attribute_length = u4()
        self.info = un()

    def read(self, f):
        self.attribute_name_index.read(f)
        self.attribute_length.read(f)
        self.info.read(f, self.attribute_length.u2int())

    def dump(self):
        result = "{\'attribute_name_index\':" + str(self.attribute_name_index.u2int())
        result += ",\'attribute_length\':" + str(self.attribute_length.u2int()) + '}'

        return result


# ------------------------------------------ constant value attribute ------------------------------------------

class constant_value_attribute:
    def __init__(self):
        self.attribute_name_index = u2()
        self.attribute_length = u4()
        self.constant_value_index = u2()

    def read(self, f):
        self.attribute_name_index.read(f)
        self.attribute_length.read(f)
        self.constant_value_index.read(f)


# ------------------------------------------ code attribute - -----------------------------------------

class code_exception:
    def __init__(self):
        self.start_pc = u2()
        self.end_pc = u2()
        self.handler_pc = u2()
        self.catch_type = u2()


class code_attribute:
    def __init__(self):
        self.attribute_name_index = u2()
        self.attribute_length = u4()
        self.max_stack = u2()
        self.max_locals = u2()
        self.code_length = u4()
        # self.code_length长度的u1数组
        self.code = []
        self.exception_table_length = u2()
        self.exception_table = []
        self.attributes_count = u2()
        # attributes_count长度的attribute_info数组
        self.attributes = []


# ------------------------------------------ stack map table attribute ------------------------------------------

class StackMapTable(attribute_info):
    def __init__(self):
        attribute_info.__init__(self)
        self.number_of_entries = u2()
        # stack map frame 数组
        self.entries = []

    def read_info(self, f):
        self.number_of_entries.read(f)
        for i in range(0, self.number_of_entries.u2int()):
            break


class stack_map_frame:
    def __init__(self):
        self.frame_type = u1()


class same_frame(stack_map_frame):
    def __init__(self):
        stack_map_frame.__init__(self)


class same_locals_1_stack_item_frame(stack_map_frame):
    def __init__(self):
        stack_map_frame.__init__(self)
        # verification_type_info的长度为1的数组
        self.stack = []


class same_locals_1_stack_item_frame_extended(stack_map_frame):
    def __init__(self):
        stack_map_frame.__init__(self)
        self.offset_delta = u2()
        # verification_type_info的长度为1的数组
        self.stack = []


class chop_frame(stack_map_frame):
    def __init__(self):
        stack_map_frame.__init__(self)
        self.offset_delta = u2()


class same_frame_extended(stack_map_frame):
    def __init__(self):
        stack_map_frame.__init__(self)
        self.offset_delta = u2()

    def read_info(self, f):
        self.offset_delta.read(f)


class append_frame(stack_map_frame):
    def __init__(self):
        stack_map_frame.__init__(self)
        self.offset_delta = u2()
        # frame_type - 251 大小的verification_type_info数组
        self.locals = []

    def read_info(self, f):
        self.offset_delta.read(f)


class full_frame(stack_map_frame):
    def __init__(self):
        stack_map_frame.__init__(self)
        self.offset_delta = u2()
        self.number_of_locals = u2()
        # number_of_locals大小的verification_type_info数组
        self.locals = []
        self.number_of_stack_items = u2()
        # number_of_stack_items大小的verification_type_info数组
        self.stack = []

    def read_info(self, f):
        self.offset_delta.read(f)
        self.number_of_locals.read(f)
        for i in range(0, self.number_of_locals.u2int()):
            break

        self.number_of_stack_items.read(f)

        for i in range(0, self.number_of_stack_items.u2int()):
            break


# ------------------------------------------ exception attribute ------------------------------------------

class exceptions_class:
    def __init__(self):
        self.inner_class_info_index = u2()
        self.outer_class_info_index = u2()
        self.inner_name_index = u2()
        self.inner_class_access_flags = u2()


class exceptions_attribute:
    def __init__(self):
        self.attribute_name_index = u2()
        self.attribute_length = u4()
        self.number_of_exceptions = u2()
        # 长度为number_of_exceptions的u2数组
        self.exception_index_table = []
        self.classes = []


# ------------------------------------------ inner classes attribute ------------------------------------------

class inner_classes_attribute:
    def __init__(self):
        self.attribute_name_index = u2()
        self.attribute_length = u4()
        self.number_of_classes = u2()


# ------------------------------------------ enclosing method attribute ------------------------------------------

class enclosing_method_attribute:
    def __init__(self):
        self.attribute_name_index = u2()
        self.attribute_length = u4()
        self.class_index = u2()
        self.method_index = u2()


# ------------------------------------------ synthetic attribute ------------------------------------------

class synthetic_attribute:
    def __init__(self):
        self.attribute_name_index = u2()
        self.attribute_length = u4()


# ------------------------------------------ signature attribute ------------------------------------------

class signature_attribute:
    def __init__(self):
        self.attribute_name_index = u2()
        self.attribute_length = u4()
        self.signature_index = u2()


# ------------------------------------------ source file attribute ------------------------------------------

class source_file_attribute:
    def __init__(self):
        self.attribute_name_index = u2()
        self.attribute_length = u4()
        self.sourcefile_index = u2()


# ------------------------------------------ source debug extension attribute ------------------------------------------

class source_debug_extension_attribute:
    def __init__(self):
        self.attribute_name_index = u2()
        self.attribute_length = u4()
        # 长度为attribute_length的u1数组
        self.debug_extension = []


# ------------------------------------------ line number table attribute ------------------------------------------

class line_number:
    def __init__(self):
        self.start_pc = u2()
        self.line_number = u2()


class line_number_table_attribute:
    def __init__(self):
        self.attribute_name_index = u2()
        self.attribute_length = u4()
        self.line_number_table_length = u2()
        # 长度为line_number_table_length的line_number数组
        self.line_number_table = []


# ------------------------------------------ local variable table attribute ------------------------------------------

class local_variable:
    def __init__(self):
        self.start_pc = u2()
        self.length = u2()
        self.name_index = u2()
        self.descriptor_index = u2()
        self.index = u2()


class local_variable_table_attribute:
    def __init__(self):
        self.attribute_name_index = u2()
        self.attribute_length = u4()
        self.local_variable_table_length = u2()
        # 长度为local_variable_table_length的local_variable数组
        self.local_variable_table = []


# ------------------------------------------ local variable type table attribute ---------------------------------------

class local_variable_type:
    def __init__(self):
        self.start_pc = u2()
        self.length = u2()
        self.name_index = u2()
        self.signature_index = u2()
        self.index = u2()


class local_variable_type_table_attribute:
    def __init__(self):
        self.attribute_name_index = u2()
        self.attribute_length = u4()
        self.local_variable_type_table_length = u2()
        # 长度为local_variable_type_table_length的local_variable_type的数组
        self.local_variable_type_table = []


# ------------------------------------------ deprecated attribute ------------------------------------------

class deprecated_attribute:
    def __init__(self):
        self.attribute_name_index = u2()
        self.attribute_length = u4()


# ------------------------------------------ attribute ------------------------------------------

class constant_value_index:
    def __init__(self):
        self.value = u2()

    def read(self, f):
        self.value.read(f)


class annotation_value:
    def __init__(self):
        self.value = annotation()

    def read(self, f):
        self.value.read(f)


class enum_const_value:
    def __init__(self):
        self.type_name_index = u2()
        self.const_name_index = u2()

    def read(self, f):
        self.type_name_index.read(f)
        self.const_name_index.read(f)


class class_info_index:
    def __init__(self):
        self.value = u2()

    def read(self, f):
        self.value.read(f)


class array_value:
    def __init__(self):
        self.num_values = u2()
        self.values = []  # element_value 数组

    def read(self, f):
        self.num_values.read(f)
        pass


class element_value:
    def __init__(self):
        self.tag = u1()
        self.value = None

    def read(self, f):
        self.tag.read(f)
        if self.tag.u2int() == 'B' \
                or self.tag.u2char() == 'C' \
                or self.tag.u2char() == 'D' \
                or self.tag.u2char() == 'F' \
                or self.tag.u2char() == 'I' \
                or self.tag.u2char() == 'J' \
                or self.tag.u2char() == 'S' \
                or self.tag.u2char() == 'Z' \
                or self.tag.u2char() == 's':
            self.value = constant_value_index()
            self.value.read(f)

        if self.tag.u2int() == 'e':
            self.value = enum_const_value()
            self.value.read(f)

        if self.tag.u2int() == 'c':
            self.value = class_info_index()
            self.value.read(f)

        if self.tag.u2int() == '@':
            self.value = annotation_value()
            self.value.read(f)

        if self.tag.u2int() == '[':
            self.value = array_value()
            self.value.read(f)


class element_value_pair:
    def __init__(self):
        self.element_name_index = u2()
        self.value = element_value()

    def read(self, f):
        self.element_name_index.read(f)
        self.value.read(f)


class annotation:
    def __init__(self):
        self.type_index = u2()
        self.num_element_value_pairs = u2()
        # 长度为num_element_value_pairs的element_value_pair数组
        self.element_value_pairs = []

    def read(self, f):
        self.type_index.read(f)
        self.num_element_value_pairs.read(f)
        for i in range(0, self.num_element_value_pairs.u2int()):
            self.element_value_pairs.append('')


class runtime_visible_annotation_attribute:
    def __init__(self):
        self.attribute_name_index = u2()
        self.attribute_length = u4()
        self.num_annotations = u2()
        # 长度为num_annotation的annotation数组
        self.annotations = []

    def read(self, f):
        self.attribute_name_index.read(f)
        self.attribute_length.read(f)
        self.num_annotations.read(f)
        self.annotations = [annotation() for _ in range(0, self.num_annotations.u2int())]
        for i in range(self.num_annotations.u2int()):
            self.annotations[i].read(f)


# ------------------------------------------ runtime invisible annotation attribute ------------------------------------

class runtime_invisible_annotation_attribute:
    def __init__(self):
        self.attribute_name_index = u2()
        self.attribute_length = u4()
        self.num_annotations = u2()
        self.annotations = []

    def read(self, f):
        self.attribute_name_index.read(f)
        self.attribute_length.read(f)
        self.num_annotations.read(f)
        self.annotations = [annotation() for _ in range(0, self.num_annotations.u2int())]
        for i in range(self.num_annotations.u2int()):
            self.annotations[i].read(f)


# ------------------------------------------ runtime visible parameter annotation attribute ----------------------------

class parameter_annotation:
    def __init__(self):
        self.num_annotations = u2()
        self.annotations = []

    def read(self, f):
        self.num_annotations.read(f)
        self.annotations = [annotation() for _ in range(0, self.num_annotations.u2int())]
        for a in self.annotations:
            a.read(f)


class runtime_visible_parameter_annotation_attribute:
    def __init__(self):
        self.attribute_name_index = u2()
        self.attribute_length = u4()
        self.num_parameters = u1()
        self.parameter_annotations = []

    def read(self, f):
        self.attribute_name_index.read(f)
        self.attribute_length.read(f)
        self.num_parameters.read(f)
        self.parameter_annotations = [parameter_annotation() for _ in range(0, self.num_parameters.u2int())]
        for pa in self.parameter_annotations:
            pa.read(f)


# ------------------------------------------ runtime invisible parameter annotation attribute --------------------------

class runtime_invisible_parameter_annotation_attribute:
    def __init__(self):
        self.attribute_name_index = u2()
        self.attribute_length = u4()
        self.num_parameters = u1()
        self.parameter_annotations = []

    def read(self, f):
        self.attribute_name_index.read(f)
        self.attribute_length.read(f)
        self.num_parameters.read(f)
        self.parameter_annotations = [parameter_annotation() for _ in range(self.num_parameters.u2int())]
        for pa in self.parameter_annotations:
            pa.read(f)


# ------------------------------------------ runtime visible type annotation attribute ---------------------------------

class type_parameter_target:
    def __init__(self):
        self.type_parameter_index = u1()

    def read(self, f):
        self.type_parameter_index.read(f)


class supertype_target:
    def __init__(self):
        self.supertype_index = u2()

    def read(self, f):
        self.supertype_index.read(f)


class type_parameter_bound_target:
    def __init__(self):
        self.type_parameter_index = u1()
        self.bound_index = u1()

    def read(self, f):
        self.type_parameter_index.read(f)
        self.bound_index.read(f)


class empty_target:
    def __init__(self):
        pass


class formal_parameter_target:
    def __init__(self):
        self.formal_parameter_index = u1()

    def read(self, f):
        self.formal_parameter_index.read(f)


class throws_target:
    def __init__(self):
        self.throws_type_index = u2()

    def read(self, f):
        self.throws_type_index.read(f)


class type_annotation:
    def __init__(self):
        self.target_type = u1()
        # self


class runtime_visible_type_annotations_attribute:
    def __init__(self):
        self.attribute_name_index = u2()
        self.attribute_length = u4()
        self.num_annotations = u1()
        self.annotations = []

    def read(self, f):
        self.attribute_name_index.read(f)
        self.attribute_length.read(f)
        self.num_annotations.read(f)
        self.annotations = [annotation() for _ in range(0, self.num_annotations.u2int())]
        for pa in self.annotations:
            pa.read(f)


# ------------------------------------------ InfoHolder ------------------------------------------

class InfoHolder:
    """
    hold info for later processing
    """
    def __init__(self):
        self.magic = None
        self.minor_version = None
        self.major_version = None
        self.constant_pool = dict()  # only store constant pool info
        self.access_flags = None
        self.this_class = None
        self.super_class = None
        self.interfaces = []
        self.fields = []
        self.methods = []
        self.attributes = []

    def parse(self):
        """
        do some query stuff, like index parsing
        :return:
        """
        pass

    def dump(self):
        for m in self.constant_pool.items():
            print(m[0], m[1].dump())
        print(self.access_flags)
        print(self.this_class)
        print(self.super_class)
        for interface in self.interfaces:
            print(interface)
        for field in self.fields:
            print(field)
        for method in self.methods:
            print(method)
        for attribute in self.attributes:
            print(attribute)


# ------------------------------------------ JavaClass ------------------------------------------------

class JavaClass:
    """
    Represent Java Class
    """
    def __init__(self):
        self.magic = u4()
        self.minor_version = u2()
        self.major_version = u2()
        self.constant_pool_count = u2()
        self.constant_pool = []
        self.access_flags = class_access_flags()
        self.this_class = u2()
        self.super_class = u2()
        self.interfaces_count = u2()
        self.interfaces = []
        self.fields_count = u2()
        self.fields = []
        self.methods_count = u2()
        self.methods = []
        self.attributes_count = u2()
        self.attributes = []


# ------------------------------------------ JavaClassReader ------------------------------------------

class JavaClassReader:
    def __init__(self):
        self.output = InfoHolder()
        # divider
        self.java_class = JavaClass()

    def read_magic(self, f):
        """
        读取魔数
        :param f:
        :return:
        """
        self.java_class.magic.read(f)

    def read_minor_version(self, f):
        """
        读取minor version信息
        :param f:
        :return:
        """
        self.java_class.minor_version.read(f)

    def read_major_version(self, f):
        """
        读取major version信息
        :param f:
        :return:
        """
        self.java_class.major_version.read(f)

    def read_constant_pool(self, f):
        """
        读取常量池信息
        :param f:
        :return:
        """
        self.java_class.constant_pool_count.read(f)
        self.java_class.constant_pool = []
        # https://stackoverflow.com/questions/41176545/the-constant-pool-lost-3-in-class-file
        need_to_skip = False
        for i in range(1, self.java_class.constant_pool_count.u2int()):
            if need_to_skip:
                need_to_skip = False
                continue
            ci = cp_info()
            ci.read(f)
            if ci.is_class():
                ci_e = class_info(ci)
            elif ci.is_field_ref():
                ci_e = field_ref_info(ci)
            elif ci.is_method_ref():
                ci_e = method_ref_info(ci)
            elif ci.is_interface_method_ref():
                ci_e = interface_method_ref_info(ci)
            elif ci.is_string():
                ci_e = string_info(ci)
            elif ci.is_integer():
                ci_e = integer_info(ci)
            elif ci.is_float():
                ci_e = float_info(ci)
            elif ci.is_long():
                need_to_skip = True
                ci_e = long_info(ci)
            elif ci.is_double():
                need_to_skip = True
                ci_e = double_info(ci)
            elif ci.is_name_and_type():
                ci_e = name_and_type_info(ci)
            elif ci.is_utf8():
                ci_e = utf8_info(ci)
            elif ci.is_method_handle():
                ci_e = method_handle_info(ci)
            elif ci.is_method_type():
                ci_e = method_type_info(ci)
            elif ci.is_invoke_dynamic():
                ci_e = invoke_dynamic_info(ci)
            else:
                raise RuntimeError("unknown stuff in constant pool")

            if ci_e is not None:
                ci_e.read_info(f)
                self.output.constant_pool[i] = ci_e

    def read_access_flags(self, f):
        """
        读取类的访问标识符
        :param f:
        :return:
        """
        self.java_class.access_flags.read(f)
        self.output.access_flags = "{\"access_flags\": \"" + str(self.java_class.access_flags.dump() + "\"}")

    def read_this_class(self, f):
        """
        读取this类信息
        :param f:
        :return:
        """
        self.java_class.this_class.read(f)
        self.output.this_class = "{\"this_class\": " + str(self.java_class.this_class.u2int()) + ", \"class_name\": \"" \
                                 + self.output.constant_pool[self.output.constant_pool[self.java_class.this_class.u2int()].name_index.u2int()].bytes.u2str() + "\"}"

    def read_super_class(self, f):
        """
        读取super类信息
        :param f:
        :return:
        """
        self.java_class.super_class.read(f)
        self.output.super_class = "{\"super_class\": " + str(self.java_class.super_class.u2int()) + \
                                  ", \"class_name\": \"" + self.output.constant_pool[self.output.constant_pool[self.java_class.super_class.u2int()].name_index.u2int()].bytes.u2str() + "\"}"

    def read_interfaces(self, f):
        """
        读取接口信息
        :param f:
        :return:
        """
        self.java_class.interfaces_count.read(f)
        for i in range(0, self.java_class.interfaces_count.u2int()):
            interface = u2()
            interface.read(f)
            self.java_class.interfaces.append(interface)
            self.output.interfaces.append("{\"interface\": \"" + str(interface.u2int()) + ", \"class_name\": \"" + self.output.constant_pool[self.output.constant_pool[interface.u2int()].name_index.u2int()].bytes.u2str() + "\"}")

    def read_fields(self, f):
        """
        读取字段信息
        :param f:
        :return:
        """
        self.java_class.fields_count.read(f)
        for i in range(0, self.java_class.fields_count.u2int()):
            fi = field_info()
            fi.read(f)
            self.output.fields.append(fi.dump())

    def read_methods(self, f):
        """
        读取方法信息
        :param f:
        :return:
        """
        self.java_class.methods_count.read(f)
        for i in range(0, self.java_class.methods_count.u2int()):
            mi = method_info()
            mi.read(f)
            self.output.methods.append(mi.dump())

    def read_attributes(self, f):
        """
        读取属性信息
        :param f:
        :return:
        """
        self.java_class.attributes_count.read(f)
        for i in range(0, self.java_class.attributes_count.u2int()):
            ai = attribute_info()
            ai.read(f)
            self.java_class.attributes.append(ai)
            self.output.attributes.append(ai.dump())

    def read(self, f):
        """
        具体的读取过程
        :param f:
        :return:
        """
        Profiler.begin()
        self.read_magic(f)
        Profiler.end('read_magic')

        Profiler.begin()
        self.read_minor_version(f)
        Profiler.end('read_minor_version')

        Profiler.begin()
        self.read_major_version(f)
        Profiler.end('read_major_version')

        Profiler.begin()
        self.read_constant_pool(f)
        Profiler.end('read_constant_pool')

        Profiler.begin()
        self.read_access_flags(f)
        Profiler.end('read_access_flags')

        Profiler.begin()
        self.read_this_class(f)
        Profiler.end('read_this_class')

        Profiler.begin()
        self.read_super_class(f)
        Profiler.end('read_super_class')

        Profiler.begin()
        self.read_interfaces(f)
        Profiler.end('read_interfaces')

        Profiler.begin()
        self.read_fields(f)
        Profiler.end('read_fields')

        Profiler.begin()
        self.read_methods(f)
        Profiler.end('read_methods')

        Profiler.begin()
        self.read_attributes(f)
        Profiler.end('read_attributes')


# ------------------------------------------ Processor ------------------------------------------

class Processor:
    def __init__(self):
        pass

    @staticmethod
    def search_constant_pool(content, pattern):
        for info in content.values():
            if info.search(pattern):
                print(info.dump())
                return True
        return False

    @staticmethod
    def _process_class_file(options, path, pattern):
        """
        when path is normal class file
        :param path:
        :param pattern:
        :return:
        """
        f = open(path, 'r')
        callback = lambda :print(path)
        Processor._process(options, f, pattern, callback)

    @staticmethod
    def _process(options, f, pattern, callback):
        reader = JavaClassReader()
        reader.read(f)
        if options.dump:
            reader.output.dump()
        else:
            if Processor.search_constant_pool(reader.output.constant_pool, pattern):
                callback()

    @staticmethod
    def _process_zip_file_with_threading(options, path, pattern):
        f = zipfile.ZipFile(path)

        import multiprocessing
        import threading
        import Queue

        def do_work(in_queue, out_queue):
            while True:
                member = in_queue.get()
                # process
                member_file = f.open(member)
                callback = lambda : print(member)
                result = Processor._process(options, member_file, pattern, callback)
                out_queue.put(result)
                in_queue.task_done()

        work = Queue.Queue()
        results = Queue.Queue()

        # start for workers
        for i in xrange(multiprocessing.cpu_count()):
            t = threading.Thread(target=do_work, args=(work, results))
            t.daemon = True
            t.start()

        # produce data
        for member in f.namelist():
            if (Processor._is_class_file(member)):
                work.put(member)

        work.join()

    @staticmethod
    def process(options, path, pattern):
        """
        入口函数
        :param path:
        :param pattern:
        :return:
        """
        if zipfile.is_zipfile(path):
            Processor._process_zip_file_with_threading(options, path, pattern)
        else:
            if Processor._is_class_file(path):
                Processor._process_class_file(options, path, pattern)

    @staticmethod
    def dump_by_file_pattern(path, file_pattern):
        """
        dump指定文件
        :param path:
        :param file_pattern:
        :return:
        """
        if zipfile.is_zipfile(path):
            with zipfile.ZipFile(path) as z:
                for member in z.namelist():
                    if file_pattern in member:
                        output_file = file('./' + Processor._generate_class_name(member), 'wr')
                        output_file.write(z.open(member).read())

    @staticmethod
    def _generate_class_name(member):
        """
        convert x/x/x/x.class to x_x_x_x.class
        :param member:
        :return:
        """
        return member.replace('/', '_')

    @staticmethod
    def _is_class_file(name):
        """
        here we only using file name, later
        :param name:
        :return:
        """
        if '.class' in name:
            return True
        return False


# ------------------------------------------ parse cmd ------------------------------------------

def _parse_cmdline(cmdline_args):
    """ Parse the list of command-line options and arguments and return a
        triple: options, args, parser -- the first two being the result of
        OptionParser.parse_args, and the third the parser object itself.`
    """
    parser = argparse.ArgumentParser(
        usage='usage: %(prog)s [options] <jar file> <pattern>',
        description='',
        prog='JarGrep',
        add_help=False)

    parser.add_argument('-h', '--help',
                        action='store_true', dest='help', default=False,
                        help='Display this information')

    parser.add_argument('-b', "--benchmarking",
                        action='store_true', dest='benchmark', default=False,
                        help='Turn on benchmarking mode')

    parser.add_argument('-v', '--verbose',
                        action='store_true', dest='verbose', default=False,
                        help='Turn on verbose mode')

    parser.add_argument('-d', '--dump',
                        action='store_true', dest='dump', default=False,
                        help='dump the specified file to the current directory')

    options, args = parser.parse_known_args(cmdline_args)

    return options, args, parser


# ------------------------------------------ benchmark ------------------------------------------

class Profiler:
    is_on = False

    start_time = 0
    end_time = 0

    def __init__(self):
        pass

    @staticmethod
    def on():
        Profiler.is_on = True

    @staticmethod
    def off():
        Profiler.is_on = False

    @staticmethod
    def _current_time_in_millisecond():
        import time
        second = int(round(time.time() * 1000))
        return second

    @staticmethod
    def begin():
        if Profiler.is_on:
            Profiler.start_time = Profiler._current_time_in_millisecond()

    @staticmethod
    def end(tag=""):
        if Profiler.is_on:
            Profiler.end_time = Profiler._current_time_in_millisecond()
            print(tag + "totally consumed " + str(Profiler.end_time - Profiler.start_time) + " milliseconds")


# ------------------------------------------ Log ------------------------------------------

class Logger:
    is_on = False

    def __init__(self):
        pass

    @staticmethod
    def on():
        Logger.is_on = True

    @staticmethod
    def off():
        Logger.is_on = False

    @staticmethod
    def log(content=''):
        if Logger.is_on:
            print(content)


def _parallel_process(options, pattern, directory):
    from pathos import multiprocessing as mp
    pool = mp.Pool(mp.cpu_count() / 2)
    from scandir import scandir, walk

    def processFilepath(root):
        try:
            for (dirpath, dirnames, filenames) in walk(root):
                for filename in filenames:
                    if 'jar' in filename:
                        filepath = os.path.join(dirpath, filename)
                        try:
                            Processor.process(options, filepath, pattern)
                        except zipfile.BadZipfile:
                            continue
                        except struct.error:
                            continue
            return root
        except:
            pass

    def generateFilepaths():
        for entry in scandir(directory):
            if entry.is_dir():
                yield entry.name

    try:
        for result in pool.imap(processFilepath, generateFilepaths()):
            if result is not None:
                pass
        pool.close()
    except KeyboardInterrupt:
        pool.terminate()
    except RuntimeError:
        pool.terminate()



# ------------------------------------------ main ------------------------------------------

def main(argv):
    options, args, parser = _parse_cmdline(argv)

    if options.verbose:
        print(args)

    # jar file to search
    path = args[1]
    # string to search
    pattern = args[2]

    if path is None or pattern is None:
        return

    if not os.path.exists(path):
        print(path + " not exist")
        return

    if options.benchmark:
        Profiler.on()
        Profiler.begin()

    if os.path.isdir(path):
        _parallel_process(options, pattern, path)
    else:
        Processor.process(options, path, pattern)

    if options.benchmark:
        Profiler.end()


sys.exit(main(sys.argv))
