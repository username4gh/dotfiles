#! /usr/bin/env python
# coding=utf-8

# /path/to/openjdk/jdk/src/java.base/share/classes/java/io/DataInputStream.java

import inspect
import argparse
import os
import struct
import sys
import zipfile


# --- basic type
# here we assume the endian-ess of class file is big-endian

class u:
    def __init__(self):
        self.value = None

    def u2str(self):
        return self.value


class u1(u):
    def __init__(self):
        u.__init__(self)

    def u2int(self):
        # read() will set self.value to utf-8 code in string
        return struct.unpack(">B", self.value)[0]

    def u2char(self):
        return struct.unpack(">c", self.value)

    def read(self, f):
        self.value = f.read(1)


class u2(u):
    def __init__(self):
        u.__init__(self)

    def u2int(self):
        # read() will set self.value to utf-8 code in string
        return struct.unpack(">H", self.value)[0]

    def read(self, f):
        self.value = f.read(2)


class u4(u):
    def __init__(self):
        u.__init__(self)

    def u2int(self):
        return struct.unpack(">I", self.value)[0]

    def read(self, f):
        self.value = f.read(4)


class un(u):
    def __init__(self):
        u.__init__(self)

    def read(self, f, n):
        self.value = f.read(n)


# ------------------------------------------ constant pool ------------------------------------------

class cp_info:
    def __init__(self):
        self.tag = u1()

    def read(self, f):
        self.tag.read(f)

    def is_class(self):
        if self.tag.u2int() == 7:
            return True
        else:
            return False

    def is_field_ref(self):
        if self.tag.u2int() == 9:
            return True
        else:
            return False

    def is_method_ref(self):
        if self.tag.u2int() == 10:
            return True
        else:
            return False

    def is_interface_method_ref(self):
        if self.tag.u2int() == 11:
            return True
        else:
            return False

    def is_string(self):
        if self.tag.u2int() == 8:
            return True
        else:
            return False

    def is_integer(self):
        if self.tag.u2int() == 3:
            return True
        else:
            return False

    def is_float(self):
        if self.tag.u2int() == 4:
            return True
        else:
            return False

    def is_long(self):
        if self.tag.u2int() == 5:
            return True
        else:
            return False

    def is_double(self):
        if self.tag.u2int() == 6:
            return True
        else:
            return False

    def is_name_and_type(self):
        if self.tag.u2int() == 12:
            return True
        else:
            return False

    def is_utf8(self):
        if self.tag.u2int() == 1:
            return True
        else:
            return False

    def is_method_handle(self):
        if self.tag.u2int() == 15:
            return True
        else:
            return False

    def is_method_type(self):
        if self.tag.u2int() == 16:
            return True
        else:
            return False

    def is_invoke_dynamic(self):
        if self.tag.u2int() == 18:
            return True
        else:
            return False


class class_info(cp_info):
    def __init__(self, ci=cp_info()):
        cp_info.__init__(self)
        self.tag = ci.tag
        self.name_index = u2()

    def read_info(self, f):
        self.name_index.read(f)

    def dump(self):
        return 'class_info:name_index==' + str(self.name_index.u2int())


class field_ref_info(cp_info):
    def __init__(self, ci=cp_info()):
        cp_info.__init__(self)
        self.tag = ci.tag
        self.class_index = u2()
        self.name_and_type_index = u2()

    def read_info(self, f):
        self.class_index.read(f)
        self.name_and_type_index.read(f)

    def dump(self):
        result = 'field_ref_info:class_index==' + str(self.class_index.u2int()) + \
                 '|name_and_type_index==' + str(self.name_and_type_index.u2int())
        return result


class method_ref_info(cp_info):
    def __init__(self, ci=cp_info()):
        cp_info.__init__(self)
        self.tag = ci.tag
        self.class_index = u2()
        self.name_and_type_index = u2()

    def read_info(self, f):
        self.class_index.read(f)
        self.name_and_type_index.read(f)

    def dump(self):
        result = 'method_ref_info:class_index==' + str(self.class_index.u2int()) + \
                 '|name_and_type_index ==' + str(self.name_and_type_index.u2int())
        return result


class interface_method_ref_info(cp_info):
    def __init__(self, ci=cp_info()):
        cp_info.__init__(self)
        self.tag = ci.tag
        self.class_index = u2()
        self.name_and_type_index = u2()

    def read_info(self, f):
        self.class_index.read(f)
        self.name_and_type_index.read(f)

    def dump(self):
        result = 'interface_method_ref_info:class_index==' + str(self.class_index.u2int()) + \
                 '|name_and_type_index==' + str(self.name_and_type_index.u2int())
        return result


class string_info(cp_info):
    def __init__(self, ci=cp_info()):
        cp_info.__init__(self)
        self.tag = ci.tag
        self.string_index = u2()

    def read_info(self, f):
        self.string_index.read(f)

    def dump(self):
        return 'string_info:string_index==' + str(self.string_index.u2int())


class integer_info(cp_info):
    def __init__(self, ci=cp_info()):
        cp_info.__init__(self)
        self.tag = ci.tag
        self.bytes = u4()

    def read_info(self, f):
        self.bytes.read(f)

    def dump(self):
        return 'integer_info: bytes==' + str(self.bytes.u2int())


class float_info(cp_info):
    def __init__(self, ci=cp_info()):
        cp_info.__init__(self)
        self.tag = ci.tag
        self.bytes = u4()

    def read_info(self, f):
        self.bytes.read(f)

    def dump(self):
        return 'float_info:bytes==' + self.bytes.u2str()


class long_info(cp_info):
    def __init__(self, ci=cp_info()):
        cp_info.__init__(self)
        self.tag = ci.tag
        self.high_bytes = u4()
        self.low_bytes = u4()

    def read_info(self, f):
        self.high_bytes.read(f)
        self.low_bytes.read(f)

    def dump(self):
        byte_s = self.high_bytes.value + self.low_bytes.value
        return 'long_info:' + str(struct.unpack('>q', byte_s)[0])


class double_info(cp_info):
    def __init__(self, ci=cp_info()):
        cp_info.__init__(self)
        self.tag = ci.tag
        self.high_bytes = u4()
        self.low_bytes = u4()

    def read_info(self, f):
        self.high_bytes.read(f)
        self.low_bytes.read(f)

    def dump(self):
        result = 'double_info:high_bytes==' + str(self.high_bytes.u2int()) + '|low_bytes==' + str(
            self.low_bytes.u2int())
        return result


class name_and_type_info(cp_info):
    def __init__(self, ci=cp_info()):
        cp_info.__init__(self)
        self.tag = ci.tag
        self.name_index = u2()
        self.descriptor_index = u2()

    def read_info(self, f):
        self.name_index.read(f)
        self.descriptor_index.read(f)

    def dump(self):
        result = 'name_and_type_info:name_index==' + str(self.name_index.u2int()) + \
                 '|descriptor_index==' + str(self.descriptor_index.u2int())
        return result


class utf8_info(cp_info):
    def __init__(self, ci=cp_info()):
        cp_info.__init__(self)
        self.tag = ci.tag
        self.length = u2()
        self.bytes = un()

    def read_info(self, f):
        self.length.read(f)
        self.bytes.read(f, self.length.u2int())

    def dump(self):
        result = 'utf8_info:length==' + str(self.length.u2int()) + '|bytes==' + self.bytes.u2str()
        return result


class method_handle_info(cp_info):
    def __init__(self, ci=cp_info()):
        cp_info.__init__(self)
        self.tag = ci.tag
        self.reference_kind = u1()
        self.reference_index = u2()

    def read_info(self, f):
        self.reference_kind.read(f)
        self.reference_index.read(f)

    def dump(self):
        result = 'method_handle_info:reference_kind==' + str(self.reference_kind.u2int())
        result += '|reference_index==' + str(self.reference_index.u2int())
        return result


class method_type_info(cp_info):
    def __init__(self, ci=cp_info()):
        cp_info.__init__(self)
        self.tag = ci.tag
        self.descriptor_index = u2()

    def read_info(self, f):
        self.descriptor_index.read(f)

    def dump(self):
        return 'method_type_info:descriptor_index==' + str(self.descriptor_index.u2int())


class invoke_dynamic_info(cp_info):
    def __init__(self, ci=cp_info()):
        cp_info.__init__(self)
        self.tag = ci.tag
        self.bootstrap_method_attr_index = u2()
        self.name_and_type_index = u2()

    def read_info(self, f):
        self.bootstrap_method_attr_index.read(f)
        self.name_and_type_index.read(f)

    def dump(self):
        result = 'invoke_dynamic_info:bootstrap_method_attr_index==' + str(self.bootstrap_method_attr_index.u2int())
        result += '|name_and_type_index==' + str(self.name_and_type_index.u2int())
        return result


# ------------------------------------------ divide line ------------------------------------------

class access_flags:
    def __init__(self):
        self.value = u2()

    def read(self, f):
        self.value.read(f)

    def dump(self):
        result = ''

        for name, value in inspect.getmembers(self):
            if 'ACC' in name:  # filter out access_flags
                if self.value.u2int() & value == value:
                    result += name
                    result += '|'

        return result.rstrip('|')


class class_access_flags(access_flags):
    ACC_PUBLIC = 0x0001
    ACC_FINAL = 0x0010
    ACC_SUPER = 0x0020
    ACC_INTERFACE = 0x0200
    ACC_ABSTRACT = 0x0400
    ACC_SYNTHETIC = 0x1000
    ACC_ANNOTATION = 0x2000
    ACC_ENUM = 0x4000


class field_access_flags(access_flags):
    ACC_PUBLIC = 0x0001
    ACC_PRIVATE = 0x0002
    ACC_PROTECTED = 0x0004
    ACC_STATIC = 0x0008
    ACC_FINAL = 0x0010
    ACC_VOLATILE = 0x0040
    ACC_TRANSIENT = 0x0080
    ACC_SYNTHETIC = 0x1000
    ACC_ENUM = 0x4000


class method_access_flags(access_flags):
    ACC_PUBLIC = 0x0001
    ACC_PRIVATE = 0x0002
    ACC_PROTECTED = 0x0004
    ACC_STATIC = 0x0008
    ACC_FINAL = 0x0010
    ACC_SYNCHRONIZED = 0x0020
    ACC_BRIDGE = 0x0040
    ACC_VARARGS = 0x0080
    ACC_NATIVE = 0x0100
    ACC_ABSTRACT = 0x0400
    ACC_STRICT = 0x0800
    ACC_SYNTHETIC = 0x1000


# ------------------------------------------ divide line ------------------------------------------

class field_info:
    def __init__(self):
        self.access_flags = field_access_flags()
        self.name_index = u2()
        self.descriptor_index = u2()
        self.attributes_count = u2()
        self.attributes = []

    def read(self, f):
        self.access_flags.read(f)
        self.name_index.read(f)
        self.descriptor_index.read(f)
        self.attributes_count.read(f)
        for i in range(0, self.attributes_count.u2int()):
            ai = attribute_info()
            ai.read(f)
            self.attributes.append(ai)

    def dump(self):
        result = 'field_info: access_flags == ' + self.access_flags.dump()
        result += ' name_index == ' + str(self.name_index.u2int())
        result += ' descriptor_index == ' + str(self.descriptor_index.u2int())
        result += ' attributes_count == ' + str(self.attributes_count.u2int())
        result += ' attributes: '

        for attribute in self.attributes:
            result += attribute.dump()

        return result


class method_info:
    def __init__(self):
        self.access_flags = method_access_flags()
        self.name_index = u2()
        self.descriptor_index = u2()
        self.attributes_count = u2()
        self.attributes = []

    def read(self, f):
        self.access_flags.read(f)
        self.name_index.read(f)
        self.descriptor_index.read(f)
        self.attributes_count.read(f)
        for i in range(0, self.attributes_count.u2int()):
            ai = attribute_info()
            ai.read(f)
            self.attributes.append(ai)

    def dump(self):
        result = 'method_info: access_flags == ' + self.access_flags.dump()
        result += ' name_index == ' + str(self.name_index.u2int())
        result += ' descriptor_index == ' + str(self.descriptor_index.u2int())
        result += ' attributes_count == ' + str(self.attributes_count.u2int())
        result += ' attributes: '

        for attribute in self.attributes:
            result += attribute.dump()

        return result


# ------------------------------------------ attribute ------------------------------------------

class attribute_info:
    def __init__(self):
        self.attribute_name_index = u2()
        self.attribute_length = u4()
        self.info = un()

    def read(self, f):
        self.attribute_name_index.read(f)
        self.attribute_length.read(f)
        self.info.read(f, self.attribute_length.u2int())

    def dump(self):
        result = "attribute_name_index == " + str(self.attribute_name_index.u2int())
        result += " attribute_length == " + str(self.attribute_length.u2int())

        return result


# ------------------------------------------ constant value attribute ------------------------------------------

class constant_value_attribute:
    def __init__(self):
        self.attribute_name_index = u2()
        self.attribute_length = u4()
        self.constant_value_index = u2()

    def read(self, f):
        self.attribute_name_index.read(f)
        self.attribute_length.read(f)
        self.constant_value_index.read(f)


# ------------------------------------------ code attribute - -----------------------------------------

class code_exception:
    def __init__(self):
        self.start_pc = u2()
        self.end_pc = u2()
        self.handler_pc = u2()
        self.catch_type = u2()


class code_attribute:
    def __init__(self):
        self.attribute_name_index = u2()
        self.attribute_length = u4()
        self.max_stack = u2()
        self.max_locals = u2()
        self.code_length = u4()
        # self.code_length长度的u1数组
        self.code = []
        self.exception_table_length = u2()
        self.exception_table = []
        self.attributes_count = u2()
        # attributes_count长度的attribute_info数组
        self.attributes = []


# ------------------------------------------ stack map table attribute ------------------------------------------

class StackMapTable(attribute_info):
    def __init__(self):
        attribute_info.__init__(self)
        self.number_of_entries = u2()
        # stack map frame 数组
        self.entries = []

    def read_info(self, f):
        self.number_of_entries.read(f)
        for i in range(0, self.number_of_entries.u2int()):
            break


class stack_map_frame:
    def __init__(self):
        self.frame_type = u1()


class same_frame(stack_map_frame):
    def __init__(self):
        stack_map_frame.__init__(self)


class same_locals_1_stack_item_frame(stack_map_frame):
    def __init__(self):
        stack_map_frame.__init__(self)
        # verification_type_info的长度为1的数组
        self.stack = []


class same_locals_1_stack_item_frame_extended(stack_map_frame):
    def __init__(self):
        stack_map_frame.__init__(self)
        self.offset_delta = u2()
        # verification_type_info的长度为1的数组
        self.stack = []


class chop_frame(stack_map_frame):
    def __init__(self):
        stack_map_frame.__init__(self)
        self.offset_delta = u2()


class same_frame_extended(stack_map_frame):
    def __init__(self):
        stack_map_frame.__init__(self)
        self.offset_delta = u2()

    def read_info(self, f):
        self.offset_delta.read(f)


class append_frame(stack_map_frame):
    def __init__(self):
        stack_map_frame.__init__(self)
        self.offset_delta = u2()
        # frame_type - 251 大小的verification_type_info数组
        self.locals = []

    def read_info(self, f):
        self.offset_delta.read(f)


class full_frame(stack_map_frame):
    def __init__(self):
        stack_map_frame.__init__(self)
        self.offset_delta = u2()
        self.number_of_locals = u2()
        # number_of_locals大小的verification_type_info数组
        self.locals = []
        self.number_of_stack_items = u2()
        # number_of_stack_items大小的verification_type_info数组
        self.stack = []

    def read_info(self, f):
        self.offset_delta.read(f)
        self.number_of_locals.read(f)
        for i in range(0, self.number_of_locals.u2int()):
            break

        self.number_of_stack_items.read(f)

        for i in range(0, self.number_of_stack_items.u2int()):
            break


# ------------------------------------------ exception attribute ------------------------------------------

class exceptions_class:
    def __init__(self):
        self.inner_class_info_index = u2()
        self.outer_class_info_index = u2()
        self.inner_name_index = u2()
        self.inner_class_access_flags = u2()


class exceptions_attribute:
    def __init__(self):
        self.attribute_name_index = u2()
        self.attribute_length = u4()
        self.number_of_exceptions = u2()
        # 长度为number_of_exceptions的u2数组
        self.exception_index_table = []
        self.classes = []


# ------------------------------------------ inner classes attribute ------------------------------------------

class inner_classes_attribute:
    def __init__(self):
        self.attribute_name_index = u2()
        self.attribute_length = u4()
        self.number_of_classes = u2()


# ------------------------------------------ enclosing method attribute ------------------------------------------

class enclosing_method_attribute:
    def __init__(self):
        self.attribute_name_index = u2()
        self.attribute_length = u4()
        self.class_index = u2()
        self.method_index = u2()


# ------------------------------------------ synthetic attribute ------------------------------------------

class synthetic_attribute:
    def __init__(self):
        self.attribute_name_index = u2()
        self.attribute_length = u4()


# ------------------------------------------ signature attribute ------------------------------------------

class signature_attribute:
    def __init__(self):
        self.attribute_name_index = u2()
        self.attribute_length = u4()
        self.signature_index = u2()


# ------------------------------------------ source file attribute ------------------------------------------

class source_file_attribute:
    def __init__(self):
        self.attribute_name_index = u2()
        self.attribute_length = u4()
        self.sourcefile_index = u2()


# ------------------------------------------ source debug extension attribute ------------------------------------------

class source_debug_extension_attribute:
    def __init__(self):
        self.attribute_name_index = u2()
        self.attribute_length = u4()
        # 长度为attribute_length的u1数组
        self.debug_extension = []


# ------------------------------------------ line number table attribute ------------------------------------------

class line_number:
    def __init__(self):
        self.start_pc = u2()
        self.line_number = u2()


class line_number_table_attribute:
    def __init__(self):
        self.attribute_name_index = u2()
        self.attribute_length = u4()
        self.line_number_table_length = u2()
        # 长度为line_number_table_length的line_number数组
        self.line_number_table = []


# ------------------------------------------ local variable table attribute ------------------------------------------

class local_variable:
    def __init__(self):
        self.start_pc = u2()
        self.length = u2()
        self.name_index = u2()
        self.descriptor_index = u2()
        self.index = u2()


class local_variable_table_attribute:
    def __init__(self):
        self.attribute_name_index = u2()
        self.attribute_length = u4()
        self.local_variable_table_length = u2()
        # 长度为local_variable_table_length的local_variable数组
        self.local_variable_table = []


# ------------------------------------------ local variable type table attribute ---------------------------------------

class local_variable_type:
    def __init__(self):
        self.start_pc = u2()
        self.length = u2()
        self.name_index = u2()
        self.signature_index = u2()
        self.index = u2()


class local_variable_type_table_attribute:
    def __init__(self):
        self.attribute_name_index = u2()
        self.attribute_length = u4()
        self.local_variable_type_table_length = u2()
        # 长度为local_variable_type_table_length的local_variable_type的数组
        self.local_variable_type_table = []


# ------------------------------------------ deprecated attribute ------------------------------------------

class deprecated_attribute:
    def __init__(self):
        self.attribute_name_index = u2()
        self.attribute_length = u4()


# ------------------------------------------ attribute ------------------------------------------

class constant_value_index:
    def __init__(self):
        self.value = u2()

    def read(self, f):
        self.value.read(f)


class annotation_value:
    def __init__(self):
        self.value = annotation()

    def read(self, f):
        self.value.read(f)


class enum_const_value:
    def __init__(self):
        self.type_name_index = u2()
        self.const_name_index = u2()

    def read(self, f):
        self.type_name_index.read(f)
        self.const_name_index.read(f)


class class_info_index:
    def __init__(self):
        self.value = u2()

    def read(self, f):
        self.value.read(f)


class array_value:
    def __init__(self):
        self.num_values = u2()
        self.values = []  # element_value 数组

    def read(self, f):
        self.num_values.read(f)
        pass


class element_value:
    def __init__(self):
        self.tag = u1()
        self.value = None

    def read(self, f):
        self.tag.read(f)
        if self.tag.u2int() == 'B' \
                or self.tag.u2char() == 'C' \
                or self.tag.u2char() == 'D' \
                or self.tag.u2char() == 'F' \
                or self.tag.u2char() == 'I' \
                or self.tag.u2char() == 'J' \
                or self.tag.u2char() == 'S' \
                or self.tag.u2char() == 'Z' \
                or self.tag.u2char() == 's':
            self.value = constant_value_index()
            self.value.read(f)

        if self.tag.u2int() == 'e':
            self.value = enum_const_value()
            self.value.read(f)

        if self.tag.u2int() == 'c':
            self.value = class_info_index()
            self.value.read(f)

        if self.tag.u2int() == '@':
            self.value = annotation_value()
            self.value.read(f)

        if self.tag.u2int() == '[':
            self.value = array_value()
            self.value.read(f)


class element_value_pair:
    def __init__(self):
        self.element_name_index = u2()
        self.value = element_value()

    def read(self, f):
        self.element_name_index.read(f)
        self.value.read(f)


class annotation:
    def __init__(self):
        self.type_index = u2()
        self.num_element_value_pairs = u2()
        # 长度为num_element_value_pairs的element_value_pair数组
        self.element_value_pairs = []

    def read(self, f):
        self.type_index.read(f)
        self.num_element_value_pairs.read(f)
        for i in range(0, self.num_element_value_pairs.u2int()):
            self.element_value_pairs.append('')


class runtime_visible_annotation_attribute:
    def __init__(self):
        self.attribute_name_index = u2()
        self.attribute_length = u4()
        self.num_annotations = u2()
        # 长度为num_annotation的annotation数组
        self.annotations = []

    def read(self, f):
        self.attribute_name_index.read(f)
        self.attribute_length.read(f)
        self.num_annotations.read(f)
        self.annotations = [annotation() for i in range(0, self.num_annotations.u2int())]
        for i in range(self.num_annotations.u2int()):
            self.annotations[i].read(f)


# ------------------------------------------ runtime invisible annotation attribute ------------------------------------

class runtime_invisible_annotation_attribute:
    def __init__(self):
        self.attribute_name_index = u2()
        self.attribute_length = u4()
        self.num_annotations = u2()
        self.annotations = []

    def read(self, f):
        self.attribute_name_index.read(f)
        self.attribute_length.read(f)
        self.num_annotations.read(f)
        self.annotations = [annotation() for i in range(0, self.num_annotations.u2int())]
        for i in range(self.num_annotations.u2int()):
            self.annotations[i].read(f)


# ------------------------------------------ runtime visible parameter annotation attribute ----------------------------

class parameter_annotation:
    def __init__(self):
        self.num_annotations = u2()
        self.annotations = []

    def read(self, f):
        self.num_annotations.read(f)
        self.annotations = [annotation() for i in range(0, self.num_annotations.u2int())]
        for a in self.annotations:
            a.read(f)


class runtime_visible_parameter_annotation_attribute:
    def __init__(self):
        self.attribute_name_index = u2()
        self.attribute_length = u4()
        self.num_parameters = u1()
        self.parameter_annotations = []

    def read(self, f):
        self.attribute_name_index.read(f)
        self.attribute_length.read(f)
        self.num_parameters.read(f)
        self.parameter_annotations = [parameter_annotation() for i in range(0, self.num_parameters.u2int())]
        for pa in self.parameter_annotations:
            pa.read(f)


# ------------------------------------------ runtime invisible parameter annotation attribute --------------------------

class runtime_invisible_parameter_annotation_attribute:
    def __init__(self):
        self.attribute_name_index = u2()
        self.attribute_length = u4()
        self.num_parameters = u1()
        self.parameter_annotations = []

    def read(self, f):
        self.attribute_name_index.read(f)
        self.attribute_length.read(f)
        self.num_parameters.read(f)
        self.parameter_annotations = [parameter_annotation() for i in range(self.num_parameters.u2int())]
        for pa in self.parameter_annotations:
            pa.read(f)


# ------------------------------------------ runtime visible type annotation attribute ---------------------------------

class type_parameter_target:
    def __init__(self):
        self.type_parameter_index = u1()

    def read(self, f):
        self.type_parameter_index.read(f)


class supertype_target:
    def __init__(self):
        self.supertype_index = u2()

    def read(self, f):
        self.supertype_index.read(f)


class type_parameter_bound_target:
    def __init__(self):
        self.type_parameter_index = u1()
        self.bound_index = u1()

    def read(self, f):
        self.type_parameter_index.read(f)
        self.bound_index.read(f)


class empty_target:
    def __init__(self):
        pass


class formal_parameter_target:
    def __init__(self):
        self.formal_parameter_index = u1()

    def read(self, f):
        self.formal_parameter_index.read(f)


class throws_target:
    def __init__(self):
        self.throws_type_index = u2()

    def read(self, f):
        self.throws_type_index.read(f)


class type_annotation:
    def __init__(self):
        self.target_type = u1()
        # self


class runtime_visible_type_annotations_attribute:
    def __init__(self):
        self.attribute_name_index = u2()
        self.attribute_length = u4()
        self.num_annotations = u1()
        self.annotations = []

    def read(self, f):
        self.attribute_name_index.read(f)
        self.attribute_length.read(f)
        self.num_annotations.read(f)
        self.annotations = [annotation() for i in range(0, self.num_annotations.u2int())]
        for pa in self.annotations:
            pa.read(f)


# ------------------------------------------ InfoHolder ------------------------------------------

class InfoHolder:
    def __init__(self):
        self.normal = []
        self.cp = []  # only store constant pool info

    def dump(self):
        for line in self.cp:
            print line


# ------------------------------------------ ConstantPoolInfoParser ------------------------------------------

# ------------------------------------------ AttributeInfoParser ------------------------------------------

# ------------------------------------------ JavaClass ------------------------------------------------

class JavaClass:
    def __init__(self):
        self.magic = u4()
        self.minor_version = u2()
        self.major_version = u2()
        self.constant_pool_count = u2()
        self.constant_pool = []
        self.access_flags = class_access_flags()
        self.this_class = u2()
        self.super_class = u2()
        self.interfaces_count = u2()
        self.interfaces = []
        self.fields_count = u2()
        self.fields = []
        self.methods_count = u2()
        self.methods = []
        self.attributes_count = u2()
        self.attributes = []


# ------------------------------------------ JavaClassReader ------------------------------------------

class JavaClassReader:
    def __init__(self):
        self.output = InfoHolder()
        # divider
        self.java_class = JavaClass()

    def read_magic(self, f):
        self.java_class.magic.read(f)

    def read_minor_version(self, f):
        self.java_class.minor_version.read(f)

    def read_major_version(self, f):
        self.java_class.major_version.read(f)

    def read_constant_pool(self, f):
        self.java_class.constant_pool_count.read(f)
        self.java_class.constant_pool = []
        # https://stackoverflow.com/questions/41176545/the-constant-pool-lost-3-in-class-file
        need_to_skip = False
        for i in range(1, self.java_class.constant_pool_count.u2int()):
            if need_to_skip:
                need_to_skip = False
                continue
            ci = cp_info()
            ci.read(f)
            if ci.is_class():
                ci_e = class_info(ci)
            elif ci.is_field_ref():
                ci_e = field_ref_info(ci)
            elif ci.is_method_ref():
                ci_e = method_ref_info(ci)
            elif ci.is_interface_method_ref():
                ci_e = interface_method_ref_info(ci)
            elif ci.is_string():
                ci_e = string_info(ci)
            elif ci.is_integer():
                ci_e = integer_info(ci)
            elif ci.is_float():
                ci_e = float_info(ci)
            elif ci.is_long():
                need_to_skip = True
                ci_e = long_info(ci)
            elif ci.is_double():
                need_to_skip = True
                ci_e = double_info(ci)
            elif ci.is_name_and_type():
                ci_e = name_and_type_info(ci)
            elif ci.is_utf8():
                ci_e = utf8_info(ci)
            elif ci.is_method_handle():
                ci_e = method_handle_info(ci)
            elif ci.is_method_type():
                ci_e = method_type_info(ci)
            elif ci.is_invoke_dynamic():
                ci_e = invoke_dynamic_info(ci)
            else:
                print str(i) + '|' + str(ci.tag.u2int())
                raise RuntimeError("unknown constant pool info")

            if ci_e is not None:
                ci_e.read_info(f)
                self.output.cp.append('#' + str(i) + '|' + ci_e.dump())

    def read_access_flags(self, f):
        self.java_class.access_flags.read(f)
        self.output.normal.append("access_flags:" + str(self.java_class.access_flags.dump()))

    def read_this_class(self, f):
        self.java_class.this_class.read(f)
        self.output.normal.append("this_class:" + str(self.java_class.this_class.u2int()))

    def read_super_class(self, f):
        self.java_class.super_class.read(f)
        self.output.normal.append("super_class:" + str(self.java_class.super_class.u2int()))

    def read_interfaces(self, f):
        self.java_class.interfaces_count.read(f)
        for i in range(0, self.java_class.interfaces_count.u2int()):
            interface = u2()
            interface.read(f)
            self.java_class.interfaces.append(interface)
            self.output.normal.append("interface:" + str(interface.u2int()))

    def read_fields(self, f):
        self.java_class.fields_count.read(f)
        for i in range(0, self.java_class.fields_count.u2int()):
            fi = field_info()
            fi.read(f)
            self.output.normal.append(fi.dump())

    def read_methods(self, f):
        self.java_class.methods_count.read(f)
        for i in range(0, self.java_class.methods_count.u2int()):
            mi = method_info()
            mi.read(f)
            self.output.normal.append(mi.dump())

    def read_attributes(self, f):
        """
        read attributes inside the ClassFile
        """
        self.java_class.attributes_count.read(f)
        for i in range(0, self.java_class.attributes_count.u2int()):
            ai = attribute_info()
            ai.read(f)
            self.java_class.attributes.append(ai)
            self.output.normal.append(ai.dump())

    def read(self, f):
        Benchmark.begin()
        self.read_magic(f)
        Benchmark.end('read_magic')

        Benchmark.begin()
        self.read_minor_version(f)
        Benchmark.end('read_minor_version')

        Benchmark.begin()
        self.read_major_version(f)
        Benchmark.end('read_major_version')

        Benchmark.begin()
        self.read_constant_pool(f)
        Benchmark.end('read_constant_pool')

        Benchmark.begin()
        self.read_access_flags(f)
        Benchmark.end('read_access_flags')

        Benchmark.begin()
        self.read_this_class(f)
        Benchmark.end('read_this_class')

        Benchmark.begin()
        self.read_super_class(f)
        Benchmark.end('read_super_class')

        Benchmark.begin()
        self.read_interfaces(f)
        Benchmark.end('read_interfaces')

        Benchmark.begin()
        self.read_fields(f)
        Benchmark.end('read_fields')

        Benchmark.begin()
        self.read_methods(f)
        Benchmark.end('read_methods')

        Benchmark.begin()
        self.read_attributes(f)
        Benchmark.end('read_attributes')


# ------------------------------------------ InfoProcessor ------------------------------------------

class FileProcessor:
    def __init__(self):
        pass

    @staticmethod
    def search(content, string):
        if string is None:
            return True
        for line in content:
            if string in line:
                print line
                return True
        return False

    @staticmethod
    def _deal_with_zip_file(path, content):
        # deal with jar file
        f = zipfile.ZipFile(path)
        for member in f.namelist():
            if FileFilter.is_class_file(member):
                member_file = f.open(member)
                reader = JavaClassReader()
                reader.read(member_file)
                if FileProcessor.search(reader.output.cp, content):
                    print member

    @staticmethod
    def _deal_with_class_file(path, content):
        f = open(path, 'r')
        reader = JavaClassReader()
        reader.read(f)
        if FileProcessor.search(reader.output.cp, content):
            reader.output.dump()

    @staticmethod
    def process(path, content=None):
        if os.path.isfile(path):
            if zipfile.is_zipfile(path):
                FileProcessor._deal_with_zip_file(path, content)
            else:
                if FileFilter.is_class_file(path):
                    FileProcessor._deal_with_class_file(path, content)


# ------------------------------------------ ZipFilter ------------------------------------------

class FileFilter:
    def __init__(self):
        pass

    @staticmethod
    def is_class_file(name):
        """
        here we only using file name, later
        :param name:
        :return:
        """
        if '.class' in name:
            return True
        return False


# ------------------------------------------ parse cmd ------------------------------------------

def _parse_cmdline(cmdline_args):
    """ Parse the list of command-line options and arguments and return a
        triple: options, args, parser -- the first two being the result of
        OptionParser.parse_args, and the third the parser object itself.`
    """
    parser = argparse.ArgumentParser(
        usage='usage: %(prog)s [options] <jar file> <pattern>',
        description='',
        prog='JarGrep',
        add_help=False)

    parser.add_argument('-h', '--help',
                        action='store_true', dest='help', default=False,
                        help='Display this information')

    parser.add_argument('-b', "--benchmarking",
                        action='store_false', dest='benchmark', default=False,
                        help='Turn on benchmarking mode')

    parser.add_argument('-v', '--verbose',
                        action='store_true', dest='verbose', default=True,
                        help='Turn on verbose mode')

    options, args = parser.parse_known_args(cmdline_args)

    return options, args, parser


# ------------------------------------------ time ------------------------------------------

class Benchmark:
    is_on = False

    start_time = 0
    end_time = 0

    def __init__(self):
        pass

    @staticmethod
    def on():
        Benchmark.is_on = True

    @staticmethod
    def current_time_in_millisecond():
        import time
        second = int(round(time.time() * 1000))
        return second

    @staticmethod
    def begin():
        if Benchmark.is_on:
            Benchmark.start_time = Benchmark.current_time_in_millisecond()

    @staticmethod
    def end(tag=""):
        if Benchmark.is_on:
            Benchmark.end_time = Benchmark.current_time_in_millisecond()
            print tag + "totally consumed " + str(Benchmark.end_time - Benchmark.start_time) + " milliseconds"


# ------------------------------------------ helper functions ------------------------------------------

def _deep_first_list_dir(result=set(), path=None):
    if os.path.exists(path):
        if os.path.isdir(path):
            for f in os.listdir(os.path.abspath(path)):
                if os.path.isfile(f):
                    result.add(os.path.abspath(f))
                else:
                    _deep_first_list_dir(result, f)
        else:
            result.add(os.path.abspath(path))


# ------------------------------------------ main ------------------------------------------

def main(argv):
    options, args, parser = _parse_cmdline(argv)

    if options.verbose:
        print args

    # jar file to search
    path = args[1] if len(args) >= 2 and args[1] is not None else os.getenv("PWD")
    # string to search
    content = args[2] if len(args) >= 3 and args[2] is not None else None

    if not os.path.exists(path):
        print path + " not exist"
        return

    if options.benchmark:
        Benchmark.on()

    Benchmark.begin()

    file_list = set()
    _deep_first_list_dir(file_list, path)
    for f in file_list:
        FileProcessor.process(f, content)

    if options.benchmark:
        Benchmark.end()


sys.exit(main(sys.argv))
